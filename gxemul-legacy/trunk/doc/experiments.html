<html><head><title>Gavare's eXperimental Emulator:&nbsp;&nbsp;&nbsp;Experimenting with GXemul</title>
<meta name="robots" content="noarchive,nofollow,noindex"></head>
<body bgcolor="#f8f8f8" text="#000000" link="#4040f0" vlink="#404040" alink="#ff0000">
<table border=0 width=100% bgcolor="#d0d0d0"><tr>
<td width=100% align=center valign=center><table border=0 width=100%><tr>
<td align="left" valign=center bgcolor="#d0efff"><font color="#6060e0" size="6">
<b>Gavare's eXperimental Emulator:&nbsp;&nbsp;&nbsp;</b></font>
<font color="#000000" size="6"><b>Experimenting with GXemul</b>
</font></td></tr></table></td></tr></table><p>

<!--

$Id: experiments.html,v 1.93 2005-12-31 15:48:30 debug Exp $

Copyright (C) 2003-2006  Anders Gavare.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

-->

<a href="./">Back to the index</a>

<p><br>
<h2>Experimenting with GXemul</h2>

<p>
<ul>
  <li><a href="#hello">Hello world</a>
  <li><a href="#expdevices">Experimental devices</a>
</ul>






<p><br>
<a name="hello"></a>
<h3>Hello world:</h3>

You might want to use the emulator to develop programs on your own,
not just run precompiled kernels such as NetBSD. To get started, I recommend
that you do two things:

<p>
<ul>
  <li>Build and install a cross-compiler for MIPS.
  <li>Compile this hello world program, and run it in the emulator.
</ul>

<p>
<table border="0"><tr><td width="40">&nbsp;</td><td>
<pre>
<font color=#f00000>/*  Hello world for GXemul  */

/*  Note: The cast to a signed int causes the address to be sign-extended
    correctly to 0xffffffffb00000xx when compiled in 64-bit mode  */
</font><font color=#a0a0a0>#define	PUTCHAR_ADDRESS		((signed int)0xb0000000)
#define	HALT_ADDRESS		((signed int)0xb0000010)

</font><font color=#c000c0>void </font><font color=#000000><a name="printchar">printchar</a>(</font><font color=#c000c0>char </font><font color=#000000>ch)
{
	*((</font><font color=#c000c0>volatile unsigned char </font><font color=#000000>*) PUTCHAR_ADDRESS) = ch;
}

</font><font color=#c000c0>void </font><font color=#000000><a name="halt">halt</a>(</font><font color=#c000c0>void</font><font color=#000000>)
{
	*((</font><font color=#c000c0>volatile unsigned char </font><font color=#000000>*) HALT_ADDRESS) = 0;
}

</font><font color=#c000c0>void </font><font color=#000000><a name="printstr">printstr</a>(</font><font color=#c000c0>char </font><font color=#000000>*s)
{
	</font><font color=#c000c0>while </font><font color=#000000>(*s)
		printchar(*s++);
}

</font><font color=#c000c0>void </font><font color=#000000>f(</font><font color=#c000c0>void</font><font color=#000000>)
{
	printstr(</font><font color=#00c000>"Hello world\n"</font><font color=#000000>);
	halt();
}
</font></pre>
</td></tr></table>

<p>(This hello world program is available here as well:
<a href="hello_mips.c"><tt>hello_mips.c</tt></a>)

<p>I recommend that you build a GCC cross compiler for the
<b>mips64-unknown-elf</b> target, and install it. Other compilers could
work too, but GCC is good because of its portability. Then try to compile
and link the hello world program:
<pre>
	$ <b>mips64-unknown-elf-gcc -O2 hello_mips.c -mips4 -mabi=64 -c</b>
	$ <b>mips64-unknown-elf-ld -Ttext 0xa800000000030000 -e f hello_mips.o -o hello_mips --oformat=elf64-bigmips</b>
	$ <b>file hello_mips</b>
	hello_mips: ELF 64-bit MSB mips-4 executable, MIPS R3000_BE, version 1 (SYSV), statically linked, not stripped
	$ <b>gxemul -q -E testmips hello_mips</b>
	Hello world

	$ <b>mips64-unknown-elf-gcc -O2 hello_mips.c -c</b>
	$ <b>mips64-unknown-elf-ld -Ttext 0x80030000 -e f hello_mips.o -o hello_mips</b>
	$ <b>file hello_mips</b>
	hello_mips: ELF 32-bit MSB mips-3 executable, MIPS R3000_BE, version 1 (SYSV), statically linked, not stripped
	$ <b>gxemul -q -E testmips hello_mips</b>
	Hello world
</pre>

<p>
As you can see above, a GCC configured for mips64-unknown-elf can produce
both 64-bit and 32-bit binaries. If you don't want to run the entire
Hello World program, but want to single-step through the execution to
learn more about how MIPS programs run, then add -V to the command line:

<p>
<pre>
	$ <b>gxemul -V -E testmips hello_mips</b>
	..
	GXemul&gt; <b>r</b>
	cpu0:    pc = a800000000030078    <f>
	cpu0:    hi = 0000000000000000    lo = 0000000000000000
	cpu0:    zr = 0000000000000000    at = 0000000000000000
	cpu0:    v0 = 0000000000000000    v1 = 0000000000000000
	..
	cpu0:    gp = a8000000000780c0    sp = ffffffffa0007f00
	cpu0:    fp = 0000000000000000    ra = 0000000000000000
	GXemul&gt; <b>s 15</b>
	&lt;f&gt;
	a800000000030078: 67bdfff0      daddiu  sp,sp,-16
	a80000000003007c: 3c04a800      lui     a0,0xa800
	a800000000030080: 3c010003      lui     at,0x3
	a800000000030084: 64840000      daddiu  a0,a0,0
	a800000000030088: 642100b8      daddiu  at,at,184
	a80000000003008c: 0004203c      dsll32  a0,a0,0
	a800000000030090: 0081202d      daddu   a0,a0,at
	a800000000030094: ffbf0000      sd      ra,0(sp)  [0xffffffffa0007ef0, data=0x0000000000000000]
	a800000000030098: 0c00c00a      jal     0xa800000000030028 &lt;printstr&gt;
	a80000000003009c: 00000000 (d)  nop
	  &lt;printstr("Hello world\n",0,0,0,..)&gt;
	&lt;printstr&gt;
	a800000000030028: 67bdfff0      daddiu  sp,sp,-16
	a80000000003002c: ffb00000      sd      s0,0(sp)  [0xffffffffa0007ee0, data=0x0000000000000000]
	a800000000030030: ffbf0008      sd      ra,8(sp)  [0xffffffffa0007ee8, data=0xa8000000000300a0]
	a800000000030034: 90820000      lbu     v0,0(a0)  [0xa8000000000300b8 = $LC0, data=0x48]
	a800000000030038: 00021600      sll     v0,v0,24
	GXemul&gt; <b>print v0</b>
	v0 = 0x0000000048000000
	GXemul&gt; <b>_</b>
</pre>

<p>The syntax of the single-step debugger shouldn't be too hard to grasp.
Type "<tt>s</tt>" to single-step one instruction. For some commands (e.g.
the single-step command), just pressing enter on a blank line will cause
the last command to be repeated. Type "<tt>quit</tt>" to quit.

<p>
Hopefully this is enough to get you inspired. :-)






<p><br>
<a name="expdevices"></a>
<h3>Experimental devices:</h3>

The emulator has several modes where it doesn't emulate any real machine.
It can either run in "bare" mode, where no devices are included by default
(just the CPU), or in a "test" mode where some simple devices are 
emulated.

<p>The test machines (<tt>testmips</tt>, <tt>testppc</tt>, etc) have the
following experimental devices:

<p>
<center><table border="0" width="80%">

  <tr>
    <td align="left" valign="top" width="200">
	<b><tt>cons</tt>:</b>
	<p>A simple console device, for writing
	characters to the controlling terminal
	and receiving keypresses.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_cons.c</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x10000000</font>
    </td>
    <td align="left" valign="top" width="25">&nbsp;</td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00</tt></td>
	    <td align="left" valign="top">
		Read: <b><tt>getchar()</tt></b> (non-blocking; returns
		<tt>0</tt> if no char was available)<br>
		Write: <b><tt>putchar(ch)</tt></b></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x10</tt></td>
	    <td align="left" valign="top">Read or write: <b><tt>halt()</tt></b><br>
		(Useful for exiting the emulator.)</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<b><tt>mp</tt>:</b>
	<p>This device controls the behaviour of CPUs in an emulated
	multi-processor system.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_mp.c</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x11000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000</tt></td>
	    <td align="left" valign="top">Read: <b><tt>whoami()</tt></b>.
		Returns the id of the CPU doing the read.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0010</tt></td>
	    <td align="left" valign="top">Read: <b><tt>ncpus()</tt></b>.
		Returns the number of CPUs in the system.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0020</tt></td>
	    <td align="left" valign="top">Write: <b><tt>startupcpu(i)</tt></b>.
		Starts CPU i. It begins execution at the address
		set by a write to startupaddr (see below).</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0030</tt></td>
	    <td align="left" valign="top">Write: <b><tt>startupaddr(addr)</tt></b>.
		Sets the starting address for CPUs.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0040</tt></td>
	    <td align="left" valign="top">Write: <b><tt>pause_addr(addr)</tt></b>.
		Sets the pause address. (TODO: This is not
		used anymore?)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0050</tt></td>
	    <td align="left" valign="top">Write: <b><tt>pause_cpu(i)</tt></b>.
		Stops all CPUs <i>except</i> CPU i.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0060</tt></td>
	    <td align="left" valign="top">Write: <b><tt>unpause_cpu(i)</tt></b>.
		Unpauses all CPUs <i>except</i> CPU i.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0070</tt></td>
	    <td align="left" valign="top">Write: <b><tt>startupstack(addr)</tt></b>.
		Sets the startup stack address. (CPUs started with
		startupcpu() above will have their stack pointer
		set to this value.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0080</tt></td>
	    <td align="left" valign="top">Read: <b><tt>hardware_random()</tt></b>.
		This produces a "random" number.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0090</tt></td>
	    <td align="left" valign="top">Read: <b><tt>memory()</tt></b>.
		Returns the number of bytes of RAM in the system.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00a0</tt></td>
	    <td align="left" valign="top">Write: <b><tt>ipi_one((nr &lt;&lt; 16) + cpuid)</tt></b>.
		Sends IPI <tt>nr</tt> to a specific CPU.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00b0</tt></td>
	    <td align="left" valign="top">Write: <b><tt>ipi_many((nr &lt;&lt; 16) + cpuid)</tt></b>.
		Sends IPI <tt>nr</tt> to all CPUs <i>except</i>
		the specified one.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top">0x00c0</tt></td>
	    <td align="left" valign="top">Read: <b><tt>ipi_read()</tt></b>.
		Returns the next pending IPI. 0 is returned if there is no 
		pending IPI (so 0 shouldn't be used for valid IPIs).
		Hardware int 6 is deasserted when the IPI queue is empty.
	    <br>Write: <b><tt>ipi_flush()</tt></b>.
		Clears the IPI queue, discarding any pending IPIs.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top">0x00d0</tt></td>
	    <td align="left" valign="top">Read: <b><tt>ncycles()</tt></b>.
		Returns approximately the number of cycles executed.
		Note: this value is not updated for every instruction,
		so it cannot be used for small measurements.</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<b><tt>fb</tt>:</b>
	<p>A simple linear framebuffer, for graphics output.
	640 x 480 pixels, 3 bytes per pixel (red, green, blue, 8 bits each).
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_fb.c</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x12000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00000-</tt><br><tt>0xe0fff</tt></td>
	    <td align="left" valign="top">Read: read pixel values.
		<br>Write: write pixel values.</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<b><tt>disk</tt>:</b>
	<p>Disk controller, which can read from and write
	to disk images. It does not use interrupts; read and
	write operations finish instantaneously.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_disk.c</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x13000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000</tt></td>
	    <td align="left" valign="top">Write: Set the offset (in bytes) from the beginning
		of the disk image. This offset will be used for the next read/write operation.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0010</tt></td>
	    <td align="left" valign="top">Write: Select the SCSI ID to be used in the next
		read/write operation.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0020</tt></td>
	    <td align="left" valign="top">Write: Start a read or write operation.
		(Writing <tt>0</tt> means a Read operation, a <tt>1</tt> means a
		Write operation.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0030</tt></td>
	    <td align="left" valign="top">Read: Get status of the last operation.
		(Status 0 means failure, non-zero means success.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4000-</tt><br><tt>0x41ff</tt>&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top">Read/Write: 512 bytes data buffer.</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<b><tt>ether</tt>:</b>
	<p>A simple ethernet controller, enough to send
	and receive packets on a simulated network.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_ether.c</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x14000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000-</tt><br><tt>0x3fff</tt></td>
	    <td align="left" valign="top">Read/write buffer for the packet to be sent/received.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4000</tt></td>
	    <td align="left" valign="top">Read: status word, one or more of these:
		<br><tt>0x01</tt>&nbsp;=&nbsp;something was received (because of
		the last command)
		<br><tt>0x02</tt>&nbsp;=&nbsp;more packets are available
		<br><i>NOTE:</i> Whenever the status word is non-zero,
			an interrupt is asserted. Reading the status word
			clears it, and deasserts the interrupt.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4010</tt></td>
	    <td align="left" valign="top">Read: get the Length of the received packet
		<br>Write: set the Length of the next packet to transmit</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4020</tt></td>
	    <td align="left" valign="top">Write: command:
		<br><tt>0x00:</tt>&nbsp;receive a packet
		<br><tt>0x01:</tt>&nbsp;send a packet</td>
	  </tr>
	</table>
    </td>
  </tr>

</table></center>

<p>
While these devices may resemble real-world hardware, they are 
intentionally made simpler to use. (An exception is the framebuffer;
some machines actually have simple linear framebuffers like this.)

<p>If the physical address is <tt>0x10000000</tt>, then for MIPS that
means that it can be accessed at virtual address
<tt>0xffffffffb0000000</tt>. (Actually it can be accessed at
<tt>0xffffffff90000000</tt> too, but devices should usually be accessed in
a non-cached manner.)

<p> (When using the PPC test machine (<tt>testppc</tt>), the addresses are
<tt>0x10000000</tt>, <tt>0x11000000</tt> etc., so no need to add any
virtual displacement.)

<p>The <b><tt>mp</tt></b>, <b><tt>disk</tt></b>, and <b><tt>ether</tt></b>
devices are agnostic when it comes to word-length. For example, when
reading offset <tt>0x0000</tt> of the <b><tt>mp</tt></b>
device, you may use any kind of read (an 8-bit read will work just as well
as a 64-bit read, although the value will be truncated to 8 bits in the
first case). You can <i>not</i>, however, read one byte from <tt>0x0000</tt>
and one from <tt>0x0001</tt>, and combine the result. The read from
<tt>0x0001</tt> will be invalid.

<p>The <b><tt>cons</tt></b> device should be accessed using 8-bit reads
and writes. Doing a getchar() (ie reading from offset <tt>0x00</tt>)  
returns <tt>0</tt> if no character was available.

<p>On MIPS, the <b><tt>cons</tt></b> device is hardwired to interrupt 2
(the lowest hardware interrupt). Whenever a character is available, the
interrupt is asserted. When there are no more available characters, the
interrupt is deasserted. (Remember that the interrupt has to be enabled in
the status register of the system coprocessor.)

<p>The <b><tt>ether</tt></b> device is hardwired to interrupt 3.

<p>The IPIs controlled by the <b><tt>mp</tt></b> device are hardwired to
interrupt 6. Whenever an IPI is "sent", interrupt 6 is asserted on the
target CPU(s), and the IPI number is added last in the IPI queue for that
CPU. It is then up to that CPU to read from offset <tt>0x00c0</tt>, to
figure out what kind of IPI it was.

<p>A simple tutorial on how to use the <tt>disk</tt> device, if not clear 
from the description above, can be found here: <a 
href="test_disk.c"><tt>test_disk.c</tt></a>









<!--

      <li><a href="http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html">Mach</a>:
	<br>Important! Run <b><tt>./configure --caches; make</tt></b>
	<br>Also important: This is broken right now. :-(
	<br>Download <a href="http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release/">http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release</a>/<a href="http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release/pmax.tar.Z">pmax.tar.Z</a>
	<br><tt><b>tar xfvz pmax.tar.Z pmax_mach/special/mach.boot.MK83.STD+ANY</b></tt>
	<br><tt><b>gxemul -e 3max -X pmax_mach/special/mach.boot.MK83.STD+ANY</b></tt>
    </ul>
  </li>

  <p>

  <li>SGI:
      <li>Linux/SGI:
	<br>Some kernels are available here: <a href="http://www.linux-mips.org/~glaurung/">http://www.linux-mips.org/~glaurung/</a>
	<br>Try running with <b><tt>-e ip32 -X</tt></b> for a graphical framebuffer, or
		<b><tt>-e ip32 -o 'console=ttyS0'</tt></b> for serial console.
	<br>Adding <b><tt>-b</tt></b> (bintrans) might work sometimes.
	<br>(You need to add <b><tt>-CR5000</tt></b> if you're trying to run
		a kernel compiled for R5000, because Linux doesn't autodetect
		the CPU type at runtime.)
	<br>Also: <a href="http://www.tal.org/~milang/o2/kernels/">http://www.tal.org/~milang/o2/kernels</a>/<a href="http://home.tal.org/~milang/o2/kernels/vmlinux64-2.6.8.1-IP32">vmlinux64-2.6.8.1-IP32</a>
	<br>Try <b><tt>-e ip32 -X -CR5000 vmlinux64-2.6.8.1-IP32</tt></b>.
	<br>And also some IP27 kernels:
		<a href="http://www.total-knowledge.com/progs/mips/kernels/vmlinux.ip27-20040428">http://www.total-knowledge.com/progs/mips/kernels/vmlinux.ip27-20040428</a>
		and
		<a href="http://www.total-knowledge.com/progs/mips/kernels/vmlinux.ip27-20040528.bz2">http://www.total-knowledge.com/progs/mips/kernels/vmlinux.ip27-20040528.bz2</a>
		(but unfortunately these lack symbols).
	<br>Try the IP27 kernels with <b><tt>-e ip27 -t</tt></b>.
      <p>
      <li><a href="http://www.openbsd.org/sgi.html">OpenBSD/sgi</a>:
	<br><a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.7/sgi/bsd.rd">ftp://ftp.openbsd.org/pub/OpenBSD/3.7/sgi/bsd.rd</a>
	<br>More recent snapshots can be found at <a href="ftp://ftp.OpenBSD.org/pub/OpenBSD/snapshots/sgi/">ftp://ftp.OpenBSD.org/pub/OpenBSD/snapshots/sgi/</a>.
	<br>Try <b><tt>gxemul -e ip32 bsd.rd</tt></b>
      <p>
      <li><a href="http://www.freebsd.org/platforms/mips.html">FreeBSD/MIPS</a>:
		I don't think public binary snapshots are available yet.
      <p>
      <li>arcdiag:
	<br>The NetBSD people have also made available an "arcdiag" for SGI-IP22:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/arch/sgimips/arcdiag.ip22">ftp://ftp.netbsd.org/pub/NetBSD/arch/sgimips/arcdiag.ip22</a>
	<br>Try running <tt><b>gxemul -e ip22 -x arcdiag.ip22</b></tt>.
    </ul>
  </li>


  <li>ARC:
      <li>Linux:
	<br><a href="ftp://ftp.linux-mips.org/pub/linux/mips/mipsel-linux/boot/vmlinux-m700-2.1.131.gz">ftp://ftp.linux-mips.org/pub/linux/mips/mipsel-linux/boot/vmlinux-m700-2.1.131.gz</a>
	<br>gunzip, and run with <b><tt>-v -J -X -N -e m700</tt></b> (Olivetti M700)
	<br>(This probably doesn't work anymore.)
      <p>
      <li>Pandora:
	<br><a href="ftp://ftp.linux-mips.org/pub/linux/mips/ancient/milo/">ftp://ftp.linux-mips.org/pub/linux/mips/ancient/milo</a>/<a href="ftp://ftp.linux-mips.org/pub/linux/mips/ancient/milo/milo-0.27.1.tar.gz">milo-0.27.1.tar.gz</a>
	<br>A generic test/diagnostics program for ARC-based machines.
	<br>Run with <b><tt>-e r94 milo-0.27.1/pandora</tt></b>
      <p>
      <li>arcdiag:
	<br>Precompiled binary:<a href="ftp://ftp.netbsd.org/pub/NetBSD/arch/arc/arcdiag">ftp://ftp.netbsd.org/pub/NetBSD/arch/arc/arcdiag</a>
	<br>(alternative: <a href="http://www.sensi.org/~alec/mips/arcdiag">http://www.sensi.org/~alec/mips/arcdiag</a>)
	<br>A generic test/diagnostics program for ARC-based machines.
	<br>Run with <b><tt>-e pica arcdiag</tt></b> (or some other ARC mode).
	<br>Example arcdiag output (from real machines):
	<br><a href="http://mail-index.netbsd.org/port-arc/2000/10/18/0001.html">http://mail-index.netbsd.org/port-arc/2000/10/18/0001.html</a> (Olivetti M700-10)
	<br><a href="http://www.sensi.org/~alec/mips/arcdiag.txt">http://www.sensi.org/~alec/mips/arcdiag.txt</a> (PICA-61)
	<br><a href="http://mail-index.netbsd.org/port-arc/2000/10/14/0000.html">http://mail-index.netbsd.org/port-arc/2000/10/14/0000.html</a> (Deskstation Tyne)
	<br><a href="http://mail-index.netbsd.org/port-arc/2004/02/01/0001.html">http://mail-index.netbsd.org/port-arc/2004/02/01/0001.html</a> (NEC RISCserver 4200)
	<br><a href="http://mirror.aarnet.edu.au/pub/NetBSD/misc/chs/arcdiag.out">http://mirror.aarnet.edu.au/pub/NetBSD/misc/chs/arcdiag.out</a> (NEC-R96)
	<br>For some machines, such as <tt><b>-e pica</b></tt>, you can
		add <b><tt>-X</tt></b> to boot with a graphical VGA-style
		console. This however is probably a bit unstable and/or
		broken right now.
      <p>
      <li>Windows NT:
	<br>Put a "Windows NT 4.0 for MIPS" CDROM (or similar) into
		your CDROM drive. (On FreeBSD systems, it is usually called
		/dev/cd0c or similar. Change that to whatever the CDROM
		is called on your system, or the name of a raw .iso image.)
	<br>I have tried this with the Swedish version, but it might
		work with other versions too.<pre>
	$ <b><tt>dd if=/dev/zero of=winnt_test.img bs=1024 count=1 seek=999000</tt></b>
	$ <b><tt>gxemul -X -e pica -d winnt_test.img -d bc6:/dev/cd0c -j MIPS\\ARCINST</tt></b>
	$ <b><tt>gxemul -X -e pica -d winnt_test.img -d bc6:/dev/cd0c -j MIPS\\SETUPLDR</tt></b>
</pre>	<br><tt>ARCINST</tt> tries to prepare the disk image for installation. (It <i>almost</i> works.)
	<br><tt>SETUPLDR</tt> should load some drivers from the cdrom, but then it crashes with a bluescreen.
    </ul>
  </li>

  <p>

  <li>HPCmips:
      <li>Linux for BE300:
	<br><a href="http://www.linux4.be/2004/linux4be20040908.zip">http://www.linux4.be/2004/linux4be20040908.zip</a>
	<br>Try <b><tt>gxemul -X -e be300 vmlinux</tt></b>
      <p>
      <li>Linux for Agenda VR3:
	<br>Download <a href="http://agenda-snow.sourceforge.net/kernel-old-versions/binary/">http://agenda-snow.sourceforge.net/kernel-old-versions/binary</a>/<a href="http://agenda-snow.sourceforge.net/kernel-old-versions/binary/root1.2.6.kernel-8.00">root1.2.6.kernel-8.00</a>
	<br>and <a href="http://vr3.uid0.sk/cd/Software/VR3_Distributions/H2O/">http://vr3.uid0.sk/cd/Software/VR3_Distributions/H2O</a>/<a href="http://vr3.uid0.sk/cd/Software/VR3_Distributions/H2O/root1.2.6.cramfs">root1.2.6.cramfs</a>.
	<br>(or <a href="http://www.ipsec.info/~www/agenda/dream-1-noxip.cramfs">http://www.ipsec.info/~www/agenda/dream-1-noxip.cramfs</a>)
	<br>Try <b><tt>gxemul -X -e vr3 -x 0xbf200000:root1.2.6.cramfs 0xbf000000:0:0xbf0005e0:root1.2.6.kernel-8.00</tt></b>
	<br>(or replace root1.2.6.cramfs with dream-1-noxip.cramfs)
	<br>Remove <b><tt>-X</tt></b> to try with serial console instead of X, and
		remove <b><tt>-b</tt></b> to try without (old) bintrans.
	<br>Add <b><tt>-o 'init=/bin/sh'</tt></b> to boot into a single-user shell.
	<br>Add <b><tt>-o 'init=/sbin/restore_defaults'</tt></b> to run
		a <tt>/sbin/restore_defaults</tt> (attempt to initialize the
		flash memory).
      <p>
      <li>Linux for MobilePro etc.:
	<br><a href="http://pc1.peanuts.gr.jp/~kei/Hard-Float/Kernels/">http://pc1.peanuts.gr.jp/~kei/Hard-Float/Kernels/</a>
	<br>Uncompress the archive to get a kernel, vmlinux-800 for example.
	<br>Try <b><tt>./gxemul -X -o 'root=/dev/hda1' -d r:disk.img -d r:disk.img -e mobilepro800 vmlinux-800</tt></b>
	<br>where disk.img is an ext2fs filesystem with contents from
	<a href="http://pc1.peanuts.gr.jp/~kei/Hard-Float/Miniroots/miniroot-20010330.tar.bz2">http://pc1.peanuts.gr.jp/~kei/Hard-Float/Miniroots/miniroot-20010330.tar.bz2</a>
	<br>(Note the double disk arguments.)
	<br>Note 2: This doesn't work yet.
      <p>
      <li><a href="http://www.disorder.ru/openbsd/be300/">OpenBSD/be300</a>:
	<br><a href="http://www.disorder.ru/openbsd/be300/bsd.rd">http://www.disorder.ru/openbsd/be300/bsd.rd</a>
	<br>Try <b><tt>gxemul -X -e be300 bsd.rd</tt></b>
	<br>Note: bintrans might be buggy, so you can try with -B if you want to.
    </ul>
  </li>

  <p>

      <li>Linux:
	<br><a href="http://people.debian.org/~pm/mips-cobalt/nfsroot/vmlinux_raq-2800.gz">http://people.debian.org/~pm/mips-cobalt/nfsroot/vmlinux_raq-2800.gz</a>
	<br>gunzip, and run with <b><tt>-E cobalt</tt></b>
	<p>
	<br><a href="http://dev.gentoo.org/~kumba/mips/cobalt/netboot/cobalt-netboot-20040428.img.gz">http://dev.gentoo.org/~kumba/mips/</a>
	<br>    <a href="http://dev.gentoo.org/~kumba/mips/cobalt/netboot/cobalt-netboot-20040428.img.gz">cobalt/netboot/cobalt-netboot-20040428.img.gz</a>
	<br><b><tt>gxemul -E cobalt cobalt-netboot-20040428.img.gz</tt></b>
      <p>
      <li>CoLo:
	<br><a href="http://www.colonel-panic.org/cobalt-mips/colo/colo-1.19.tar.gz">http://www.colonel-panic.org/cobalt-mips/colo/colo-1.19.tar.gz</a>
	<br><tt><b>tar zxvf colo-1.19.tar.gz colo-1.19/binaries/colo-rom-image.bin</b></tt>
	<br><tt><b>gxemul -Q -Ecobalt -v 0xbfc00000:colo-1.19/binaries/colo-rom-image.bin</b></tt>
	<br>(This doesn't work yet.)

      <p>
      <li>Linux:
	<br>A Linux kernel (2.2.21-pre1-xr7) is available from
	<a href="http://playstation2-linux.com/projects/xrhino-kernel/">http://playstation2-linux.com/projects/xrhino-kernel/</a>
	<br>Try running with <b><tt>-X -E playstation2</tt></b>  (<b><tt>-X</tt></b> is required, for the framebuffer).
    </ul>
  </li>

  <p>



meshcube Linux:
	<br>A Linux kernel is available from
	<a href="http://www.meshcube.org/feed/stable/">http://www.meshcube.org/feed/stable</a>/<a href="http://www.meshcube.org/feed/stable/kernel-image-mtx_2.4.24-3_mipsel.ipk">kernel-image-mtx_2.4.24-3_mipsel.ipk</a>
	<br>(This is a Debian package, you can use <tt><b>ar</b></tt> and
		<tt><b>tar</b></tt> to extract kernel.img from it.)
	<br>Try running with <b><tt>-E meshcube 0x80800000:kernel.img</tt></b>.

  <li><a href="http://www.seattlewireless.net/index.cgi/NetgearWG602">NetGear WG602</a>:
      <li>Linux:
	<br>A Linux kernel is available from
	<a href="ftp://downloads.netgear.com/files/wg602_v1715.zip">ftp://downloads.netgear.com/files/wg602_v1715.zip</a>
	<br>(Unzip wg602_v1715.zip to get WG602_V1715.img.)
	<br>Try running with <b><tt>-E netgear 0xbfc80000:0x40:WG602_V1715.img</tt></b>.
	<br>(It takes some time to decompress the kernel, so be patient.)
	<br>(This doesn't really work yet.)


      <li>Linux:
	<br><a href="http://jocelyn.mayer.free.fr/qemu-ppc/linux_images/2.4.25-PPC/vmlinux">http://jocelyn.mayer.free.fr/qemu-ppc/linux_images/2.4.25-PPC/vmlinux</a>
	<br><tt><b>gxemul -E prep -v -t vmlinux</b></tt>

      <li><a href="http://www.bebox.nu/os.php?s=os/linux/index">Linux/bebox</a>:
	<br><a href="http://www.bebox.nu/files/linux/BeBox-scsi-980610.gz">http://www.bebox.nu/files/linux/BeBox-scsi-980610.gz</a>
	<br><tt><b>gunzip BeBox-scsi-980610.gz</b></tt>
	<br><tt><b>gxemul -E bebox 0x3100:0x400:BeBox-scsi-980610</b></tt>

-->




</p>

</body>
</html>
