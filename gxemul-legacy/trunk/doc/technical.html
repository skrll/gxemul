<html>
<head><title>mips64emul technical documentation</title>
</head>
<body bgcolor=#ffffff text=#000000 link=#4040f0 vlink=#404040 alink=#ff0000>

<!--

$Id: technical.html,v 1.5 2004-07-09 04:11:45 debug Exp $

Copyright (C) 2004 by Anders Gavare.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

-->

<p> 
<table width=100%>
  <tr><td width=100% bgcolor=#808070><font color=#ffffe0 size=6>
  <b>mips64emul</b></font></td></tr></table>

<p>
<ul>
  <h3><a href="index.html">User Documentation</a></h3>
  <h3>Technical Documentation</h3>
</ul>
  
<p><br>
<p>
 <table width=100%>
  <tr><td width=100% bgcolor=#b0b0b0><font color="#8f2f2f" size=4>
	Technical Documentation
  </font></td></tr>
</table>

<p>
This page describes some of the internals of mips64emul. For more general 
documentation, please read the <a href="index.html">User
Documentation</a>.

<p>
<font color="#ff0000">NOTE: This page is under construction.</font>

<ul>
  <li><a href="#overview">Overview</a>
  <li><a href="#optimizations">Optimizations</a>
  <li><a href="#net">Networking</a>
  <li><a href="#devices">Emulation of hardware device</a>
  <p>
  <li><a href="#feedback">Feedback</a>
</ul>




<p><br>
<a name="overview"></a>
<h3>Overview</h3>

In simple terms, mips64emul is just a simple fetch-and-execute
loop; an instruction is fetched from memory, and executed.

<p>
In reality, a lot of things need to be handled. Before each instruction is 
executed, the emulator checks to see if any interrupts are asserted which 
are not masked away. If so, then an INT exception is generated. Exceptions 
cause the program counter to be set to a specific value, and some of the 
system coprocessor's registers to be set to values signifying what kind of 
exception it was (an interrupt exception in this case).

<p>
Reading instructions from memory is done through a TLB, a translation
lookaside buffer. The TLB on MIPS is software controlled, which means that 
the program running inside the emulator (for example an operating system 
kernel) has to take care of manually updating the TLB. Some memory 
addresses are translated into physical addresses directly, some are 
translated into valid physical addresses via the TLB, and some memory 
references are not valid. Invalid memory references cause exceptions.

<p>
After an instruction has been read from memory, the emulator checks which
opcode it contains and executes the instruction. Executing an instruction
usually involves reading some register and writing some register, or perhaps a 
load from memory (or a store to memory). The program counter is increased 
for every instruction.

<p>
Some memory references point to physical addresses which are not in the 
normal RAM address space. They may point to hardware devices. If that is 
the case, then loads and stores are converted into calls to a device 
access function. The device access function is then responsible for 
handling these reads and writes.  For example, a graphical framebuffer 
device may put a pixel on the screen when a value is written to it, or a 
serial controller device may output a character to stdout when written to.




<p><br>
<a name="optimizations"></a>
<h3>Optimizations</h3>

TODO.



<p><br>
<a name="net"></a>
<h3>Networking</h3>

<font color="#ff0000">Networking is experimental stuff, not 
included in the 0.1.1 release!</font>

<p>
Running an entire operating system under emulation is very interesting in 
itself, but for several reasons, running a modern OS without access to 
TCP/IP networking is a bit akward. Hence, I feel the need to implement TCP/IP 
(networking) support in the emulator.

<p>
As far as I have understood it, there seems to be two different ways to go:

<ol>
  <li>Forward ethernet packets from the emulated ethernet controller to
	the host machine's ethernet controller, and capture incoming 
	packets on the host's controller, giving them back to the
	emulated OS. Characteristics are:
	<ul>
	  <li>Requires <i>direct</i> access to the host's NIC, which
		means on most platforms that the emulator cannot be
		run as a normal user!
	  <li>Reduced portability, as not every host operating system
		uses the same programming interface for dealing with
		hardware ethernet controllers directly.
	  <li>When run on a switched network, it might be problematic to
		connect from the emulated OS to the OS running on the
		host, as packets sent out on the host's NIC are not
		received by itself. (?)
	</ul>
  <p>
  or
  <p>
  <li>Whenever the emulated ethernet controller wishes to send a packet,
	the emulator looks at the packet and creates a response. Packets
	that can have an immediate response never go outside the emulator,
	other packet types have to be converted into suitable other
	connection types (UDP, TCP, etc). Characteristics:
	<ul>
	  <li>Each packet type sent out on the emulated NIC must be handled.
		This means that I have to do a lot of coding.
		(I like this, because it gives me an opportunity to
		learn about networking protocols.)
	  <li>By not relying on access to the host's NIC directly,
		portability is maintained. (It would be sad if the networking
		portion of a portable emulator isn't as portable as the
		rest of the emulator.)
	  <li>Connecting from the emulated OS to the host's OS should
		not be problematic.
	  <li>The emulated OS will experience the network just as a single
		machine behind a NAT gateway/firewall would. The emulated
		OS is thus automatically protected from the outside world.
	</ul>
</ol>

Other emulators that I have heard of seem to use the first one, if they 
support networking.

<p>
Since I have choosen the second kind of implementation, I have to write 
support explicitly for any kind of network protocol that should be
supported. As of 2004-07-09, the following has been implemented and seems 
to work under at least NetBSD/pmax under DECstation -D2 emulation:

<ul>
  <li>ARP requests sent out from the emulated NIC are interpreted,
	and converted to ARP responses. (This is used by the emulated OS
	to find out the MAC address of the gateway.)
  <li>ICMP echo requests (that is the kind of packet produced by the
	<b>ping</b> program) are interpreted and converted to ICMP echo
	replies, <i>regardless of the IP address</i>. This means that
	running ping from within the emulated OS will <i>always</i>
	receive a response. The ping packets never leave the emulated
	environment.
  <li>UDP packets are interpreted and passed along to the outside world.
	If the emulator receives an UDP packet from the outside world, it
	is converted into an UDP packet for the emulated OS. (This is not
	implemented very well yet, but seems to be enough for nameserver
	lookups and tftp file transfers, see below.)
  <li><font color="#ff0000">NOTE: TCP is <i>NOT</i> yet working!</font>
  <li>RARP is not implemented yet. (I haven't needed it so far.)
</ul>

The gateway machine, which is the only "other" machine that the emulated 
OS sees on its emulated network, works as a NAT-style firewall/gateway. It 
has a fixed IPv4 address of 10.0.0.254. An OS running in the emulator 
can thus have any 10.x.x.x address; a typical choice would be 10.0.0.1.

<p>
With emulated NetBSD/pmax, running the following commands should enable
the emulated NIC:
<pre>
	# <b>ifconfig le0 10.0.0.1</b>
	# <b>route add default 10.0.0.254</b>
	add net default: gateway 10.0.0.254
</pre>

If you want nameserver lookups to work, you need a valid /etc/resolv.conf 
as well:
<pre>
	# <b>echo nameserver 129.16.1.3 > /etc/resolv.conf</b>
</pre>
(But replace 129.16.1.3 with the actual real-world IP address of your
nearest nameserver.)
<p>
Now, host lookups should work:
<pre>
	$ <b>host -a www.netbsd.org</b>
	Trying null domain
	rcode = 0 (Success), ancount=2
	The following answer is not authoritative:
	The following answer is not verified as authentic by the server:
	www.netbsd.org  86400 IN        AAAA    2001:4f8:4:7:290:27ff:feab:19a7
	www.netbsd.org  86400 IN        A       204.152.184.116
	For authoritative answers, see:
	netbsd.org      83627 IN        NS      uucp-gw-2.pa.dec.com
	netbsd.org      83627 IN        NS      ns.netbsd.org
	netbsd.org      83627 IN        NS      adns1.berkeley.edu
	netbsd.org      83627 IN        NS      adns2.berkeley.edu
	netbsd.org      83627 IN        NS      uucp-gw-1.pa.dec.com
	Additional information:
	ns.netbsd.org   83627 IN        A       204.152.184.164
	uucp-gw-1.pa.dec.com	172799 IN	A	204.123.2.18
	uucp-gw-2.pa.dec.com	172799 IN	A	204.123.2.19
</pre>

As TCP is <i>NOT</i> yet implemented, most normal TCP/IP applications will 
not work. However, it is possible to transfer files from another host via 
the network, without having to resort to using .tar files as diskimages.
The tftp program, for example, uses UDP.

<pre>
	# <b>tftp 12.34.56.78</b>
	tftp> <b>get filename</b>
	Received XXXXXX bytes in X.X seconds
	tftp> <b>quit</b>
	# 
</pre>

or, to do it non-interactively (with ugly output):

<pre>
	# <b>echo get filename | tftp 12.34.56.78</b>
	tftp> Received XXXXXX bytes in X.X seconds
	tftp> #
</pre>

This, of course, requires that you have put the file <i>filename</i> in 
the root directory of the tftp server (12.34.56.78).


<p><br>
<a name="devices"></a>
<h3>Emulation of hardware device</h3>

Each file in the device/ directory is responsible for one hardware
device. These are used from src/machine.c, when initializing which hardware a
particular machine model will be using.
(I'll be using the name 'foo' as the name of the device in all these
examples.  This is pseudo code, it might need some modification to 
actually compile and run.)
<p>

Each device should have the following:
<p>

<ul>
  <li>An init function in dev_foo.c. It would typically look
	something like this:
<pre>
	void dev_foo_init(struct cpu *cpu, struct memory *mem,
	    uint64_t baseaddr, int irq_nr)
	{
		struct foo_data *d;

		d = malloc(sizeof(struct foo_data));
		if (d == NULL) {
			fprintf(stderr, "out of memory\n");
			exit(1);
		}
		memset(d, 0, sizeof(struct foo_data));
		d->irq_nr = irq_nr;

		memory_device_register(mem, "foo", baseaddr,
		    DEV_FOO_LENGTH, dev_foo_access, d);

		/*  This should only be here if the device
		    has a tick function:  */
		cpu_add_tickfunction(cpu, dev_foo_tick, d,
		    FOO_TICKSHIFT);
	}
</pre><br>

  <li>The init function, the access function (described further down)
	and DEV_FOO_LENGTH should be defined in include/devices.h.
  <p>
  <li>At the top of dev_foo.c, the foo_data struct should be defined.
<pre>
	struct foo_data {
		int	irq_nr;
		/*  ...  */
	}
</pre><br>

  <li>If foo has a tick function (that is, something that needs to be
	run at regular intervals) then FOO_TICKSHIFT and a tick function
	need to be defined as well:
<pre>
	#define FOO_TICKSHIFT		10

	void dev_foo_tick(struct cpu *cpu, void *extra)
	{
		struct foo_data *d = (struct foo_data *) extra;

		if (.....)
			cpu_interrupt(cpu, d->irq_nr);
		else
			cpu_interrupt_ack(cpu, d->irq_nr);
	}
</pre><br>

  <li>And last but not least, the device should have an access function.
	The access function is called whenever there is a load or store
	to an address which is in the device' memory mapped region.
<pre>
	int dev_foo_access(struct cpu *cpu, struct memory *mem,
	    uint64_t relative_addr, unsigned char *data, size_t len,
	    int writeflag, void *extra)
	{
		struct foo_data *d = extra;
		uint64_t idata = 0, odata = 0;

		idata = memory_readmax64(cpu, data, len);
		switch (relative_addr) {
		/* .... */
		}

		if (writeflag == MEM_READ)
			memory_writemax64(cpu, data, len, odata);

		/*  Perhaps interrupts need to be asserted or
		    deasserted:  */
		dev_foo_tick(cpu, extra);

		/*  Return successfully.  */
		return 1;
	}
</pre><br>
</ul>
<p>
The return value of the access function has until 20040702 been a 
true/false value; 1 for success, or 0 for device access failure. A device 
access failure will be seen as a MIPS DBE exception from the CPU.
<p>
Right now I'm converting the devices to support arbitrary memory latency 
values. The return value is now the number of cycles that the read or 
write access took. A value of 1 means one cycle, a value of 10 means 10 
cycles. Negative values are used for device access failures, and the 
absolute value of the value is then the number of cycles; a value of -5 
means that the access failed, and took 5 cycles.
<p>
To be compatible with pre-20040702 devices, a return value of 0 is treated 
by the caller (in src/memory.c) as a value of -1.




<p><br>
<a name="feedback"></a>
<h3>Feedback:</h3>

If you have comments, don't hesitate to mail me at
md1gavan at mdstud.chalmers.se.


<hr>

</body>
</html>

