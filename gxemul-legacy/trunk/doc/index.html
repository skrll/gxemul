<html>
<head><title>mips64emul documentation</title>
</head>
<body bgcolor=#ffffff text=#000000 link=#4040f0 vlink=#404040 alink=#ff0000>

<p>
<table width=100%>
  <tr><td width=100% bgcolor=#808070><font color=#ffffe0 size=6>
  <b>mips64emul</b></font></td></tr></table>

<p>
<table width=100%>
  <tr><td width=100% bgcolor=#b0b0b0><font color=#8f2f2f size=4>
	Documentation
  </font></td></tr>
</table>

<p>
This "documentation" is just a collection of questions and answers
and various bits of information. Enjoy! :-)

<ul>
  <li><a href="#overview">Overview</a>
  <li><a href="#emulmodes">Which machines does mips64emul emulate?</a>
  <li><a href="#build">How to compile/build the emulator</a>
  <li><a href="#use">How to use the emulator</a>
  <li><a href="#cani">Can I run &lt;os-name&gt; in the emulator?</a>
  <li><a href="#hello">Hello world</a>
  <li><a href="#portmips">Porting operating systems to MIPS using mips64emul</a>
  <li><a href="#disk">How to start the emulator with a disk image</a>
  <li><a href="#userland">Running userland binaries</a>
  <li><a href="#decrom">Using a PROM image from a DECstation</a>
  <li><a href="#feedback">Feedback</a>
</ul>


<p><br>
<a name="overview"></a>
<h4>Overview:</h4>

mips64emul is a MIPS machine emulator. It tries to emulate a MIPS CPU
and enough additional hardware to be able to run real (unmodified)
operation systems, such as NetBSD, Linux, Irix, Ultrix, or OpenBSD.
It is a spare time hobby project, and not everything has been implemented yet.
<p>
The emulator might be useful when playing around with porting operating systems
to the MIPS architecture, or for academic purposes (experimenting with MIPS).
One of the reasons for writing mips64emul in the first place was to
be able to experiment with large-scale SMP systems.
Emulation of SMP systems is still experimental, though.


<p><br>
<a name="emulmodes"></a>
<h4>Which machines does mips64emul emulate?</h4>

A few different machine types are emulated. Here, "emulated" does not mean
that the machine type is emulated <i>well</i>, just that there is such
an emulation mode.

<ul>
  <li>DECstation/DECsystem machines, made by Digital Equipment Corp.
  <li>Silicon Graphics MIPS-based machines
  <li>A NEC RISCstation 2250 (an "ARC" compliant machine)
  <li>Cobalt
  <li>Sony Playstation 2
  <li>Handheld "hpcmips" devices
</ul>
<p>
Some notes about the list above:  The machines above have 64-bit
capable CPUs, except most DECstations. There were upgrades from R3000 to
R4000 available for some DECstations, but Ultrix was still running in 32-bit
mode (I think).  Unfortunately, even if most of these machine types have
64-bit CPUs in them (or even 128-bit, the Playstation 2's R5900 CPU
is a bit weird), operating systems often run in 32-bit mode on them.
<p>
There are other machines that use/used MIPS cpus, for example the
Playstation (1) and the Nintendo 64 game systems, but no free OS is ported
to those platforms as far as I know, so they might not be too interesting
to emulate.
<p>
Playstation 2 is among the emulated machine types, but the emulation done
by mips64emul is <i>not</i> suitable for playing games. Running Linux and
NetBSD is a lot more fun :-)


<p><br>
<a name="build"></a>
<h4>How to compile/build the emulator:</h4>

Uncompress the .tar.gz file, and run
<pre>
	$ <b>./configure</b>
	$ <b>make</b>
</pre>
This should work on any Unix-like system. If not, please report that as
a bug to me.  (Specific snapshots of mips64emul might have problems on
different platforms.)


<p><br>
<a name="use"></a>
<h4>How to use the emulator:</h4>

The emulator contains code which tries to emulate the workings of MIPS-like CPUs
and surrounding hardware found in real machines, but no actual MIPS ROM code or
MIPS program code.  You will need some form of program to run in the emulator.
<p>
You can use pre-compiled kernels (for example NetBSD or Linux), ROM images, or other programs
that are in MIPS binary format. A couple of different file formats are supported
(ELF, a.out, ECOFF, SREC, raw binaries).
<p>
As an example, let's say you want to emulate a Silicon Graphics O2 machine.
This machine type is also known as IP32, in the SGI namespace. Let's also
say that you want to run NetBSD on this emulated machine. A pre-compiled kernel
for NetBSD/sgimips can be found here:
<a href="http://ftp.sunet.se/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.gz">
http://ftp.sunet.se/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.gz</a>
<p>
Once you have downloaded the kernel and gunzip'd it, you can try it out in the
emulator like this:
<pre>
	$ <b>./mips64emul -G32 -q netbsd-INSTALL</b>
</pre>
-G signifies that we want SGI emulation, and 32 is the SGI-specific machine type.
-q supresses debug messages. If everything works like it should, you should see NetBSD's boot messages...
<pre>
	$ <b>./mips64emul -G32 -q netbsd-INSTALL</b>
	zs channel 0 had address 0xbfbd9830
	 [ no symbols available ]
	CPU clock speed = 3.00Mhz
	Copyright (c) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
	    The NetBSD Foundation, Inc.  All rights reserved.
	Copyright (c) 1982, 1986, 1989, 1991, 1993
	    The Regents of the University of California.  All rights reserved.
	
	NetBSD 1.6.2 (RAMDISK) #0: Wed Feb 11 06:38:58 UTC 2004
	    autobuild@tgm.netbsd.org:/autobuild/netbsd-1-6-PATCH002/sgimips/OBJ/autobuild/netbsd-1-6-PATCH002/src/sys/arch/sgimips/compile/RAMDISK
	32768 KB memory, 29988 KB free, 0 for ARCS, 1740 KB in 435 buffers
	mainbus0 (root): SGI-IP32 [SGI, 8], 1 processor
	cpu0 at mainbus0: MIPS R5000 CPU (0x2321) Rev. 2.1 with built-in FPU Rev. 1.0
	cpu0: 32KB/32B 2-way set-associative L1 Instruction cache, 48 TLB entries
	cpu0: 32KB/32B 2-way set-associative write-back L1 Data cache
	crime0 at mainbus0 addr 0x14000000: rev 1.1
	mace0 at mainbus0 addr 0x1f000000
	mace0: isa sts 0
	mace0: isa msk 0
	com0 at mace0 offset 0x390000 intr 4: ns16550a, working fifo
	com0: console
	com1 at mace0 offset 0x398000 intr 4: ns16550a, working fifo
	pckbc0 at mace0 offset 0x320000 intr 5: stub
	lpt0 at mace0 offset 0x380000 intr 4: stub
	mcclock0 at mace0 offset 0x3a0000
	mec0 at mace0 offset 0x280000 intr 3: MAC-110 Ethernet, rev 0
	mec0: station address 00:00:00:00:00:00
	mec0: sorry, this is not a real driver
	macepci0 at mace0 offset 0x80000 intr 7: rev 1
	macepci0: ctrl 0
	pci0 at macepci0 bus 0
	pci0: i/o space, memory space enabled, rd/line, rd/mult, wr/inv ok
	biomask 7f netmask 7f ttymask 7f clockmask ff
	md0: internal 3072 KB image area
	boot device: <unknown>
	root on md0a dumps on md0b
	WARNING: clock gained 28 days -- CHECK AND RESET THE DATE!
	root file system type: ffs
	Terminal type? [vt100] <b>_</b>
</pre>
and after typing vt100 (or just pressing enter), you'll reach NetBSD's install program.
You will not be able to install anything though, as the AHC disk controller isn't
emulated yet.
<p>
To exit the emulator, type CTRL-C. By typing CTRL-B instead, a CTRL-C is sent to
the emulated program.
<p>
For some emulated machine types, a graphical framebuffer console is supported.
NetBSD/pmax (kernel found here: <a href="http://ftp.sunet.se/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.gz">
http://ftp.sunet.se/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.gz</a>)
running on an emulated DECstation 5000 supports this:
<pre>
	$ <b>./mips64emul -D2 -X -Y2 -q -I1000000 -M12 netbsd-INSTALL</b>
</pre>
-D2 stands for DECstation, type 2; -X means to use X-windows to get a graphical
framebuffer; -Y2 is used to scale down the window by a factor 2x2; -q supresses
debug output; -I1000000 lets the emulated clock chip on DECstations have
a more realistic pace; and -M12 sets the amount of emulated memory to 12 MB.
The result should looks something like this:
<p>
<center>
<img src="netbsd-pmax-framebuffer.gif">
</center>


<p><br>
<a name="cani"></a>
<h4>Can I run &lt;os-name&gt; in the emulator?</h4>

The answer is probably <b>NO</b>, unless &lt;os-name&gt; is one of a few things that I have tried
myself.
Under DECstation emulation, NetBSD, Linux, and some Ultrix kernels work.
Under SGI emulation, NetBSD and Linux work a bit, but I've never gotten anything out of Irix except
for a panic message or two.
<p>
To sum it up: there is no guarantee that anything specific will run in the emulator,
but NetBSD (or possibly Linux) is a good starting point for someone who wants to
experiment. Linux kernels don't usually have ramdisks in them, so until some disk
controller device has been implemented, NetBSD is the way to go if you want to
reach userland.
<p>
Also, the set of OSes that work is obviously very different for different emulation
modes.


<p><br>
<a name="hello"></a>
<h4>Hello world:</h4>

You might want to use the emulator to develop programs on your own,
not just run precompiled kernels such as NetBSD. To get started, I'd recommend
you do two things:
<ul>
  <li>Build and install a cross-compiler for MIPS.
  <li>Compile this hello world program, and run it in the emulator.
</ul>
<p>
If the emulator is launched without specifying which machine to emulate,
it will emulate only a CPU and very few devices. One of those devices
is a console putchar() device, at a fixed address.
<pre>
	/*  Hello world for mips64emul  */

	#define	PUTCHAR_ADDRESS		0xb0000000

	void printchar(char ch)
	{
		*((volatile unsigned char *) PUTCHAR_ADDRESS) = ch;
	}

	void printstr(char *s)
	{
		while (*s)
			printchar(*s++);
	}

	void f(void)
	{
		printstr("Hello world\n");
		for (;;)
			;
	}
</pre>
This hello world program is available here as well: <a href="hello.c">hello.c</a>
<p>
I'd recommend you build a GCC cross compiler for the <b>mips64-unknown-elf</b>
target, and install it. Other compilers might work too, but GCC is good because
of its portability. Then try to compile the hello world program:
<pre>
	$ <b>mips64-unknown-elf-gcc hello.c -mips4 -mabi=64 -c</b>
	$ <b>mips64-unknown-elf-ld -Ttext 0x80030000 -e f hello.o -o hello --oformat=elf64-bigmips</b>
	$ <b>file hello</b>
	hello: ELF 64-bit MSB mips-4 executable, MIPS R3000_BE, version 1 (SYSV), statically linked, not stripped
	$ <b>./mips64emul -q hello</b>
	Hello world

	$ <b>mips64-unknown-elf-gcc hello.c -c</b>
	$ <b>mips64-unknown-elf-ld -Ttext 0x80030000 -e f hello.o -o hello</b>
	$ <b>file hello</b>
	hello: ELF 32-bit MSB mips-3 executable, MIPS R3000_BE, version 1 (SYSV), statically linked, not stripped
	$ <b>./mips64emul -q hello</b>
	Hello world
</pre>
As you can see above, a GCC configured for mips64-unknown-elf can produce
both 64-bit and 32-bit binaries.
<p>
Hopefully this is enough to get you inspired. :-)


<p><br>
<a name="portmips"></a>
<h4>Porting operating systems to MIPS using mips64emul:</h4>

Is this a good idea?  The answer is yes and no, depending on what you are
trying to port to. If you are developing an operating system or operating
system kernel of your own, and wish to target MIPS in general (that is,
the CPU but not hardware specific to any one machine type), then the
answer might be yes, for experimental purposes.
<p>
However, if you think that you can port an operating system
to, say, the Silicon Graphics machine mode of mips64emul and hope that your
operating system will run on a real SGI machine, then you will most
likely fail. mips64emul simply does not emulate things well enough for that to work.
A lot of the devices that are emulated are based on guesswork (for example,
by studying code in NetBSD that uses the device, and thereby figure
out more or less how the device is supposed to work).
<p>
In many cases, hardware devices in mips64emul are only implemented well
enough to fool eg. NetBSD that they are working correctly, while in fact
they don't work very much at all.  Please keep this in mind, if you plan
to use mips64emul when porting your code to MIPS.


<p><br>
<a name="disk"></a>
<h4>How to start the emulator with a disk image:</h4>

<font color=#f00000><b>NOTE: No disk controller works yet, so diskimages CAN NOT actually be used!</b></font>
<p>
Simply add <i>-d diskimagefilename</i> to the command line. For example, if you
want to run a NetBSD/pmax kernel on an emulated DECstation machine, you
would use a command line such as this:
<pre>
	$ <b>./mips64emul -D2 -q -d pmax_diskimage.fs netbsd-pmax-INSTALL</b>
</pre>
<p>
It is possible to have more than one disk. For each -d argument, a disk
image is added; the first will be SCSI target 0, the second will be target 1, and so on.
<pre>
	$ <b>./mips64emul -D2 -q -d disk0.raw -d disk1.raw -d disk2.raw netbsd-pmax-INSTALL</b>
</pre>


<p><br>
<a name="userland"></a>
<h4>Running userland binaries:</h4>

You can run (some) userland programs as well. This will not emulate any
particular machine, but instead try to translate syscalls from for example
NetBSD/pmax into the host's OS' syscalls. For example, running /bin/hostname
or /bin/date and similarly trivial programs from the NetBSD/pmax distribution
works:
<pre>
	$ <b>./mips64emul -qu1 pmax_bin_hostname</b>
	tab.csbnet.se
	$ <b>./mips64emul -qu1 pmax_bin_date</b>
	Sun Jan 25 02:26:14 GMT 2004
	$ <b>./mips64emul -qu1 pmax_bin_sleep</b>
	usage: pmax_bin_sleep seconds
	$ <b>./mips64emul -qu1 pmax_bin_sleep 5</b>
	$ <b>./mips64emul -qu1 pmax_bin_sync</b>
</pre>
There's also an Ultrix4 emulation mode:
<pre>
	$ <b>./mips64emul -qu2 ultrix4_bin_date</b>
	UNIMPLEMENTED ultrix syscall 54
	UNIMPLEMENTED ultrix syscall 62
	Mon Feb  9 12:50:59 WET 2004
	$ <b>./mips64emul -qu2 ultrix4_bin_hostname</b>
	tab.csbnet.se
</pre>
Userland syscall emulation is still in its beginning stages, so almost
nothing works.
<p>
Irix userland emulation might also be possible to add.


<p><br>
<a name="decrom"></a>
<h4>Using a PROM image from a DECstation:</h4>

<i>(The general ideas in this section applies to using ROM images from other machines as well.)</i>
<p>
Raw PROM images from real machines can, in a few cases, be used. One
case which I've tried is to use a DECstation 5000/125 PROM image.
ROM images from other machines might work as well, but ROM code is
usually much more sensitive to correctness of the emulator than
operating system kernels or userland programs are.
<p>
The image first needs to be extracted from the machine. I presume
that these PROMs are not legal to redistribute, so you really need
to extract the PROM from a physical machine that you own. There are
several ways to do this.
<ul>
  <li>Use hardware to read the PROM chip(s) directly. Not easy if you
	don't have such a hardware reader.
  <li>Copy the PROM memory range into a file, from a running
	operating system. You need a running OS, and it must
	have access to the PROM memory range. NetBSD, for example,
	doesn't allow that from userland.
  <li>Hook up a serial console and dump using the PROM's own dump
	command.
</ul>
<p>
The easiest way is to hook up a serial console. The terminal must be
able to capture output to a file.
<p>
These are approximately the commands that I used:
<pre>
        >><b>cnfg</b>                             <i>Show machine configuration</i>

        >><b>printenv</b>                         <i>Show environment variables</i>

        >><b>setenv more 0</b>                    <i>This turns off the More messages</i>

        >><b>e -x 0xbfc00000:0xbfffffff</b>       <i>Dump the PROM data</i>
</pre>
<p>
Remember that DECstations are little endian, so if the dump data
looks like this:
<pre>
        bfc00000:  0x0bf0007e
</pre>
then the bytes in memory are actually 0x7e, 0x00, 0xf0, and 0x0b.
<p>
At 9600 bps, about 10KB can be dumped per minute, so it takes a while.
Once enough of the PROM has been dumped, you can press CTRL-C to break out.
Then, restore the more environment variable:
<pre>
        >><b>setenv more 24</b>
</pre>
<p>
Now, convert the data you just saved (little-endian words -> bytes),
and store in a file. Let's call this file DECstation5000_125_promdump.bin.
<pre>
        $ <b>./decprom_dump_txt_to_bin DECstation5000_125_promdump.txt DECstation5000_125_promdump.bin</b>
</pre>
This binary image can now be used in the emulator:
<pre>
	$ <b>./mips64emul -D3 -Q -M128 -q 0xbfc00000:DECstation5000_125_promdump.bin</b>

	KN02-BA V5.7e   
	?TFL:  3/scc/access (1:Ln1 reg-12: actual=0x00 xpctd=0x01) [KN02-BA]
	?TFL:  3/scc/io (1:Ln0 tx bfr not empty. status=0X 0) [KN02-BA]
	...
	--More--?TFL: 3/scsi/cntl (CUX, cause= 1000002C)
	>><b>?</b>
	 ? [cmd]
	 boot [[-z #] [-n] #/path [ARG...]]
	 cat SCRPT
	 cnfg [#]
	 d [-bhw] [-S #] RNG VAL
	 e [-bhwcdoux] [-S #] RNG
	 erl [-c]
	 go [ADR]
	 init [#] [-m] [ARG...]
	 ls [#]
	 passwd [-c] [-s]
	 printenv [EVN]
	 restart
	 script SCRPT
	 setenv EVN STR
	 sh [-belvS] [SCRPT] [ARG..]
	 t [-l] #/STR [ARG..]
	 unsetenv EVN
	>><b>cnfg</b>
	 3: KN02-BA  DEC      V5.7e    TCF0  (128 MB)
	                                     (enet: 00-00-00-00-00-00)
	                                     (SCSI = 7)
	 0: PMAG-BA  DEC      V5.3a    TCF0
	>><b>printenv</b>
	 boot=
	 testaction=q
	 haltaction=h
	 more=24
	 #=3
	 console=*
	 osconsole=3
	>>
</pre>
<i>(Note: at the moment, this doesn't work. I must have broken something when
fixing something else, but this is what it looked like at the time.)</i>
<p>
During bootup, the PROM complains <i>a lot</i> about hardware failures.
That's because the emulator doesn't emulate the hardware well enough yet.
<p>
The command line options used are:
-D3 for DECstation model 3 (5000/xxx), -Q to supress the emulator's own PROM
call emulation, -M128 for 128MB RAM (because mips64emul doesn't correctly
emulate memory detection well enough for the PROM to accept, so it will
always believe there is 128MB ram anyway), and -q to supress debug messages.
The 0xbfc00000 in front of the filename tells mips64emul that it is a raw
binary file which should be loaded at a specific virtual address.


<p><br>
<a name="feedback"></a>
<h4>Feedback:</h4>

If you have comments, don't hesitate to mail me at
md1gavan @mdstud.chalmers.se.


<hr>
<pre>$Id: index.html,v 1.15 2004-03-30 01:00:35 debug Exp $</pre>

</body>
</html>
