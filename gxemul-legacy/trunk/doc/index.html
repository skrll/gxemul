<html>
<head><title>mips64emul User Documentation</title>
</head>
<body bgcolor="#ffffff" text="#000000" link="#4040f0" vlink="#404040" alink="#ff0000">
<p>
<table width="100%">
  <tr><td width="100%" bgcolor="#808070"><font color="#ffffe0" size="6">
  <b>mips64emul</b></font></td></tr>
</table>
<p>
<!-- The first 10 lines are cut away by the homepage updating script.  -->


<!--

$Id: index.html,v 1.135 2004-10-29 15:22:54 debug Exp $

Copyright (C) 2003-2004  Anders Gavare.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

-->

<ul>
  <li><h3>User Documentation</h3>
  <li><h3><a href="technical.html">Technical Documentation</a></h3>
</ul>


<hr>
<p><br>
<h2>mips64emul User Documentation</h2>

<p><br>
<h3>Contents:</h3>

<ul>
  <li><a href="#overview">Overview</a>
  <li><a href="#free">Is mips64emul free software?</a>
  <li><a href="#build">How to compile/build the emulator</a>
  <li><a href="#emulmodes">Which machines does mips64emul emulate?</a>
  <li><a href="#cpus">Which CPU types does mips64emul emulate?</a>
  <li><a href="#guestos">Which guest OSes are possible to run?</a>
  <li><a href="#netbsdinstall">How to install NetBSD/pmax in the emulator</a>
  <li><a href="#netbsdarcinstall">How to install NetBSD/arc in the emulator</a>
  <li><a href="#openbsdinstall">How to install OpenBSD/pmax in the emulator</a>
  <li><a href="#openbsdarcinstall">How to install OpenBSD/arc in the emulator</a>
  <li><a href="#ultrixinstall">How to install Ultrix/RISC in the emulator</a>
  <li><a href="#sprite">How to run Sprite for DECstation in the emulator</a>
  <li><a href="#declinux">How to install Debian GNU/Linux for DECstation in the emulator</a>
  <li><a href="#mach">How to run Mach/PMAX in the emulator</a>
  <li><a href="#experiments">Experiments with other kernels and guest OSes:</a>
  <li><a href="#fbres">Changing the framebuffer resolution</a>
  <li><a href="#networking">Networking</a>
  <li><a href="#hello">Hello world</a>
  <li><a href="#portmips">Porting operating systems to MIPS using mips64emul</a>
  <li><a href="#disk">How to start the emulator with a disk image</a>
  <li><a href="#largeimages">How to extract large gzipped disk images</a>
  <li><a href="#userland">Running userland binaries</a>
  <li><a href="#decrom">Using a PROM image from a DECstation</a>
  <p>
  <li><a href="#feedback">Feedback</a>
</ul>



<p><br>
<a name="overview"></a>
<h3>Overview:</h3>

mips64emul is a MIPS machine emulator.

The goals are to emulate MIPS-like
CPUs and enough surrounding hardware to be able to run unmodified
operating systems (such as
<a href="http://www.netbsd.org/">NetBSD</a>,
Ultrix,
<a href="http://www.linux-mips.org/">Linux</a>,
<a href="http://www.freebsd.org/platforms/mips.html">FreeBSD</a>,
or
<a href="http://www.openbsd.org/pmax.html">OpenBSD</a>)
as if they were running on a real machine,
and to assist in experiments involving MIPS-like code in general.
<p>
Note: This is a spare time hobby project,
and many things are not implemented yet.
<p>
It is important to keep in mind that devices and CPUs are not really emulated
correctly, they are only "faked" well enough to make eg. NetBSD run.
That said, the emulator could still be of interest for academic research
and experiments, such as learning how to write an OS for a MIPS-like
machine, or profiling SMP, memory usage, or system call patterns.
<p>
The emulator is written in C, depends on no external libraries (except X11,
which is optional), and should compile and run on any Unix-like system. If it doesn't, that
is to be considered a bug. No MIPS compiler toolchain is needed if the program you
wish to run in the emulator is already in binary form. No ROM images are
needed, the emulator will try to emulate things such as PROM calls by
itself. However, if you have a ROM image, it might be possible to run it
in the emulator.

<p>
(MIPS is a registered trademark of MIPS Technologies. This project is
not affiliated with MIPS Technologies in any way whatsoever. There are
probably also many other words and names used in this documentation that
are trademarked; they are owned by their respective owners.)



<p><br>
<a name="free"></a>
<h3>Is mips64emul free software?</h3>

Yes. Although developing mips64emul has been very time consuming, I don't 
see any point in not letting others make use of the emulator, or reuse 
the code. mips64emul is distributed under a free license.
The code I have written is released under a 2-clause BSD-style license
(or "revised BSD-style" if one wants to use
<a href="http://www.gnu.org/philosophy/bsd.html">GNU jargon</a>.)

<p>
Apart from the code I have written, some files are copied from other sources
such as NetBSD, for example header files containing symbolic names of
bitfields in device registers. They are also covered by similar licenses,
but with some additional clauses. If you plan to redistribute mips64emul
(for example as a binary package), or reuse code from mips64emul,
then you should check those files for their license terms.

<p>
(The licenses usually require that the original Copyright and license 
terms are included when you make a copy or modification. The "easiest way 
out" if you plan to redistribute code from mips64emul is to simply supply 
the source code. You should however check individual files for details.)





<p><br>
<a name="build"></a>
<h3>How to compile/build the emulator:</h3>

Uncompress the .tar.gz distribution file, and run
<pre>
	$ <b>./configure</b>
	$ <b>make</b>
</pre>

<p>
This should work on any Unix-like system. If it doesn't, then please mail me a
bug report.

<p>
(Note for Windows users: there is a small possibility that this will also
work under Cygwin, but this is totally unsupported, as I have no such system
to try it on.)

<p>
The emulator's performance is highly dependent on both runtime settings
and on compiler settings, so you might want to experiment with different
CC and CFLAGS environment variable values. For example, on a modern PC, 
you could try the following:
<p>
<pre>
        $ <b>CFLAGS="-mcpu=pentium4 -O3" ./configure</b>
        $ <b>make</b>
</pre>

<p>
A number of different configure options are available:
<pre>
        <i>--caches</i>       enable cache emulation
        <i>--delays</i>       enable instruction latency/delay emulation
        <i>--mips16</i>       enable MIPS16 instruction support
        <i>--nobintrans</i>   configure without bintrans support, even if the host supports it
        <i>--nox11</i>        configure without X11 support
        <i>--userland</i>     enable userland emulation
</pre>

<p>
<i>--caches</i> enables emulation of caches (R3000 only, so far). This causes an 
overall slowdown, so don't enable it unless you need it. Enabling caches
does <i>not</i> by itself mean correct cache miss penalties and such (you
need both <i>--caches</i> and <i>--delays</i> for that) but it is needed to fool some
operating system kernels (eg Mach/pmax) that the cache works like it should.
<p>
<i>--delays</i> simulates instruction latencies. Memory accesses can have penalties.
When combined with <i>--caches</i>, cache misses cause penalties as well. This 
causes an overall slowdown, so don't enable it unless you need it.
<p>
<i>--mips16</i> enables MIPS16 instruction support. This doesn't really work yet, 
as only very few MIPS16 instructions are translated. This causes an overall
slowdown, so don't enable it unless you need it.
<p>
<i>--nobintrans</i> disables dynamic binary translation completely.
<p>
<i>--nox11</i> disables X11 support completely. (If the configure script cannot
compile a small X11 test program, it will be disabled anyway.)  This might 
improve performance slightly, but makes it impossible to run certain 
things in the emulator.
<p>
<i>--userland</i> enables userland emulation support. This is experimental, only a 
few syscalls are implemented, mostly as a proof-of-concept. This might 
cause a tiny slowdown, so don't enable it unless you need it.

<p>
The possible configure options might differ between different releases and
snapshots, so this list may be incomplete.





<p><br>
<a name="emulmodes"></a>
<h3>Which machines does mips64emul emulate?</h3>

A few different machine types are emulated.
The machine types that are emulated best at the moment are:
<ul>
  <li>DECstation/DECsystem machines, made by Digital Equipment Corp.
  <li>Acer Pica-61 (an ARC machine)
</ul>
<p>
Some other machine types are also emulated, but the degree to which the 
emulation works for these is generally not very high.
<ul>
  <li>Silicon Graphics' MIPS-based machines
  <li>Other ARC machines (NEC RISCstation 2250 and 2200, RISCserver 4200,
	Deskstation Tyne, Microsoft-Jazz MIPS Magnum and Olivetti M700)
  <li>Cobalt
  <li>Sony Playstation 2
  <li>Skeletons for generic
	"<a href="http://www.netbsd.org/Ports/hpcmips/">hpcmips</a>",
	<a href="http://www.netbsd.org/Ports/newsmips/history.html">Sony NeWS</a>,
	<a href="http://www.meshcube.org/">MeshCube</a>,
	<a href="http://www.seattlewireless.net/index.cgi/NetgearWG602">NetGear WG602</a>,
	and
	Linksys WRT54G
</ul>

<p>
Unfortunately, even if most of these machine types have
64-bit CPUs in them (or 128-bit, the Playstation 2),
operating systems often run in 32-bit mode on them.

<p>
There are other machines that use/used MIPS processors, for example the
Playstation (1) and the Nintendo 64 game systems, but no free OS is ported
to those platforms as far as I know, so they might not be too interesting
to emulate.

<p>
Playstation 2 is among the emulated machine types, but the emulation done
by mips64emul is <i>not</i> suitable for playing games. Running Linux and
NetBSD is a lot more fun :-)

<p>
In addition to specific machine types, a "bare" machine can be emulated.
This mode is used when the emulator is started without specifying which
machine type to emulate.
A bare machine consists of one or more CPUs and a few experimental devices such
as:
<p>
<ul>
  <li>a console I/O device (putchar() and getchar()...)
  <li>an inter-processor communication device, for SMP experiments
</ul>
<p>
This mode is useful if you wish to experiment with software for MIPS-like
systems, but do not with to target any specific real-world machine type, 
for example for educational purposes or generic MIPS related experiments.




<p><br>
<a name="cpus"></a>
<h3>Which CPU types does mips64emul emulate?</h3>

While other emulators aim to emulate only one specific CPU type (eg R3000),
mips64emul does not. The ideal goal would be to support "all" MIPS-like CPUs.
(In reality, however, no CPU is emulated 100% correctly by mips64emul.)
Support for specific processor features and instructions is added when needed.
<p>
Both 32-bit and 64-bit CPU types are emulated, and also some aspects of
TX79/R5900 (128-bit).





<p><br>
<a name="guestos"></a>
<h3>Which guest OSes are possible to run?</h3>

This table sums up the guest OSes that run well enough to be considered
"working" in the emulator, that is, they can be installed onto some kind
of harddisk image and be interacted with similar to a real machine:

<p><br>
 <center>
  <table border="0">
    <tr><td>
      <table border="0">
	<tr><td align="center">
	  <table border="0">
	    <tr>
	      <td valign="top"><b><u>Guest&nbsp;OS:</u></b></td>
	      <td width="20">&nbsp;</td>
	      <td valign="top"><b><u>Emulation&nbsp;mode:</u></b></td>
	      <td width="40">&nbsp;</td>
	      <td valign="top"><b><u>Guest&nbsp;OS:</u></b></td>
	      <td width="20">&nbsp;</td>
	      <td valign="top"><b><u>Emulation&nbsp;mode:</u></b></td>
	    </tr>

	    <tr>
	      <td valign="top"><a href="http://www.netbsd.org/Ports/pmax/">NetBSD/pmax</a></td>
	      <td></td>
	      <td valign="top">DECstation</td>
	      <td></td>
	      <td valign="top"><a href="http://www.netbsd.org/Ports/arc/">NetBSD/arc</a></td>
	      <td></td>
	      <td valign="top">ARC (Acer Pica)</td>
	    </tr>

	    <tr>
	      <td valign="top"><a href="http://www.openbsd.org/pmax.html">OpenBSD/pmax</a></td>
	      <td></td>
	      <td valign="top">DECstation</td>
	      <td></td>
	      <td valign="top"><a href="http://www.openbsd.org/arc.html">OpenBSD/arc</a></td>
	      <td></td>
	      <td valign="top">ARC (Acer Pica)</td>
	    </tr>

	    <tr>
	      <td valign="top">Ultrix/RISC</td>
	      <td></td>
	      <td valign="top">DECstation</td>
	      <td></td>
	      <td valign="top"><a href="http://www.cs.berkeley.edu/projects/sprite/retrospective.html">Sprite</a></td>
	      <td></td>
	      <td valign="top">DECstation</td>
	    </tr>
	  </table>
	</td></tr>

	<tr><td height="15">&nbsp;</td></tr>

	<tr><td>
	  <center>
	    <table border="0">
	      <tr>
		<td width=150 align=center><a href="netbsd-pmax-20040630.png"><img src="netbsd-pmax-20040630_small.png"></a></td>
		<td width=150 align=center><a href="openbsd-pmax-20040710.png"><img src="openbsd-pmax-20040710_small.png"></a></td>
		<td width=150 align=center><a href="ultrix4.5-20040706.png"><img src="ultrix4.5-20040706_small.gif"></a></td>
	      </tr>
	      <tr>
		<td align=center>NetBSD 1.6.2/pmax</td>
		<td align=center>OpenBSD 2.8/pmax</td>
		<td align=center>Ultrix 4.5</td>
	      </tr>
	      <tr>
		<td height=10>&nbsp;</td>
	      </tr>
	      <tr>
		<td width=150 align=center><a href="20041024-netbsd-arc-installed.gif"><img src="20041024-netbsd-arc-installed_small.gif"></a></td>
		<td width=150 align=center><a href="20041024-openbsd-arc-installed.gif"><img src="20041024-openbsd-arc-installed_small.gif"></a></td>
		<td width=150 align=center><a href="sprite-20040711.png"><img src="sprite-20040711_small.png"></a></td>
	      </tr>
	      <tr>
		<td align=center>NetBSD 1.6.2/arc</td>
		<td align=center>OpenBSD 2.3/arc</td>
		<td align=center>Sprite</td>
	      </tr>
	    </table>
	  </center>
	</td></tr>
      </table>
    </td></tr>
  </table>
 </center>

<p><br>
(It is non-trivial to get a specific operating system or OS kernel to
run in the emulator, so don't expect the list above to grow too quickly.)
<p>
There is no guarantee that anything
specific will run in the emulator, but NetBSD (or possibly Linux) is a
good starting point for someone who wants to experiment.




<p><br>
<a name="netbsdinstall"></a>
<h3>How to install NetBSD/pmax in the emulator:</h3>

To run NetBSD/pmax in the emulator (on an emulated DECstation machine), 
you first need to install NetBSD onto a disk image. To NetBSD, the disk 
image looks and acts like a real SCSI disk, but it is just a normal 
file in the host's filesystem.
<p>
You need to do the following:
<ol start="1">
  <li>Compile mips64emul:<pre>
	$ <b>./configure; make</b>

</pre>
  <li>Create an empty harddisk image, which will be the root disk
	that NetBSD installs itself onto:<pre>
	$ <b>dd if=/dev/zero of=netbsddisk.img bs=1 count=512 seek=1900000000</b>

</pre>
</ol>
<p>
From this point, there are two separate ways to continue the installation.
You can either download a CD-ROM iso image (and let the installation 
program copy files from the CD-ROM image to the harddisk image), or you 
can install via ftp. For an installation from a CD-ROM image, follow these 
steps:
<p>
<ol start="3">

  <li>Download a NetBSD CD-ROM iso image: (approx. 75 MB)<pre>
	<a href="ftp://ftp.netbsd.org/pub/NetBSD/iso/1.6.2/pmaxcd.iso">ftp://ftp.netbsd.org/pub/NetBSD/iso/1.6.2/pmaxcd.iso</a>

</pre>
  <li>Start the emulator like this:<pre>
	$ <b>./mips64emul -X -D2 -d netbsddisk.img -d bc:pmaxcd.iso</b>
</pre>
</ol>
<p>
For an ftp install, substitute steps 3 and 4 above with these:
<p>
<ol start="3">

  <li>Download a NetBSD pmax INSTALL kernel (1.3 MB), and gunzip it:<pre>
	<a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.gz</a>
	MD5 (netbsd-INSTALL.gz) = 14254f73996e8c1abccdcf5e0a0b6521

	$ <b>gunzip netbsd-INSTALL.gz</b>

</pre>
  <li>Start the emulator like this:<pre>
	$ <b>./mips64emul -X -D2 -d netbsddisk.img -O netbsd-INSTALL</b>
</pre>
</ol>

<p>
(If you don't want to use a graphical framebuffer during the install,
you can remove <b>-X</b> from the command line, but then make sure you
choose 'vt100' when prompted with which terminal type to use, and not
'rcons'.)

<p>
Then proceed like you would do if you were installing NetBSD on a real
DECstation.  Even if the emulator is running on a very fast host system,
you should expect the installation to take quite some time.
If you are installing from the network, then suitable networking 
parameters are as follows:<pre>
	Which device shall I use? [le0]: <b>le0</b>
	..
	Your DNS domain: <b>mydomain.com</b>
	Your host name: <b>foo</b>
	Your IPv4 number: <b>10.0.0.1</b>
	IPv4 Netmask [0xff000000]: <b>0xff000000</b>
	IPv4 gateway: <b>10.0.0.254</b>
	IPv4 name server: <b>129.16.1.3</b>       <i>&lt;--- replace this with your actual real-world nameserver</i>
</pre>

<p>
When the installation is completed, the following command should start
NetBSD from the harddisk image:<pre>
	$ <b>./mips64emul -X -M64 -D2 -d netbsddisk.img</b>
</pre>
<p>
Use <b>startx</b> to start X windows.
<p>
If you want to run without the X framebuffer, use this instead:<pre>
	$ <b>./mips64emul -D2 -d netbsddisk.img</b>
</pre>






<p><br>
<a name="netbsdarcinstall"></a>
<h3>How to install NetBSD/arc in the emulator:</h3>

It is possible to run NetBSD/arc on an emulated Acer PICA-61 in the
emulator.

<p>
To install NetBSD/arc from a CDROM image onto an emulated harddisk image,
follow these instructions:

<p>
<ol start="1">
  <li>Compile mips64emul:<pre>
	$ <b>./configure; make</b>

</pre>
  <li>Create an empty harddisk image, which will be the root disk
	that NetBSD installs itself onto:<pre>
	$ <b>dd if=/dev/zero of=nbsd_arc.img bs=1024 count=1 seek=800000</b>

</pre>
  <li>Download a NetBSD/arc CDROM image from ftp:<pre>
	<a href="ftp://ftp.netbsd.org/pub/NetBSD/iso/1.6.2/arccd.iso">ftp://ftp.netbsd.org/pub/NetBSD/iso/1.6.2/arccd.iso</a>
	76873728 bytes, md5 = efce79ecd6d0421551ab1eae7e6a34ee

</pre>
  <li>Download a NetBSD/arc installation (ramdisk) kernel,
	and gunzip it:<pre>
	<a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd.RAMDISK.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd.RAMDISK.gz</a>

</pre>
  <li>Start the emulator using this command line:<pre>
	$ <b>./mips64emul -A2 -d nbsd_arc.img -d arccd.iso netbsd.RAMDISK</b>

</pre>
  <li>From now on, you have to use your imagination, as there is no
	automatic installation program for NetBSD/arc. Here are some tips
	and hints on how you can proceed with the install:<pre>
	$ <b>mount /dev/cd0a /mnt2</b>
	$ <b>disklabel -i -I sd0</b>    (for example 'a', '4.2BSD', '1c',
	    '600M', 'b', 'swap', '601M', '$', 'P', 'W', 'y', and 'Q')
	$ <b>newfs /dev/sd0a</b>
	$ <b>mount /dev/sd0a /mnt</b>
	$ <b>cd /mnt</b>
	$ <b>for a in /mnt2/arc/binary/sets/*.tgz; do tar xvzpf $a; done</b>
	$ <b>cd dev; sh MAKEDEV all</b>
	$ <b>cd ../etc; echo "rc_configured=YES" &gt;&gt; rc.conf</b>
	$ <b>cat > /mnt/etc/fstab</b>
	    /dev/sd0a / ffs rw 1 1
	    (ctrl-d)
	$ <b>cd /; umount /mnt; umount /mnt2</b>
	$ <b>halt</b>

</pre>
  <li>Download a generic NetBSD/arc kernel,
	and gunzip it:<pre>
	<a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd-GENERIC.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd-GENERIC.gz</a>

</pre>
</ol>

<p>
You can now use the generic NetBSD/arc kernel to boot from the harddisk 
image, using the following command:
<p>
<pre>
	$ <b>./mips64emul -A2 -d nbsd_arc.img netbsd-GENERIC</b>

</pre>





<p><br>
<a name="openbsdinstall"></a>
<h3>How to install OpenBSD/pmax in the emulator:</h3>

Installing OpenBSD/pmax is a bit harder than installing NetBSD/pmax.
You should first read the section above on how to install NetBSD,
before continuing here. If you have never installed OpenBSD on any
architecture, then you need a great deal of patience to do this.
If, on the other hand you are used to installing OpenBSD, then
this should be no problem for you.

<p>
OpenBSD/pmax died at release 2.8 of OpenBSD, so you should be
aware of the fact that this will not give you an up-to-date OpenBSD
system. The files are available at this URL:
<pre>
	<a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/pmax/">ftp://ftp.openbsd.org/pub/OpenBSD/2.8/pmax/</a>
</pre>

<p>
Following these instructions <i>might</i> work. If not, then use
common sense and imagination to modify them as you see fit.

<p>
<ol>
  <li>Compile mips64emul:<pre>
	$ <b>./configure; make</b>

</pre>
  <li>Create an empty harddisk image, which will be the root disk
	that OpenBSD installs itself onto:<pre>
	$ <b>dd if=/dev/zero of=openbsddisk.img bs=1 count=512 seek=900000000</b>

</pre>
  <li>Download the entire pmax directory from the ftp server: (approx. 99 MB)<pre>
	$ <b>wget -r ftp://ftp.openbsd.org/pub/OpenBSD/2.8/pmax/</b>

</pre>

  <li>Execute the following commands:<pre>
	$ <b>mv ftp.openbsd.org/pub/OpenBSD/2.8/pmax/simpleroot28.fs.gz .</b>
	$ <b>gunzip simpleroot28.fs.gz</b>
	$ <b>chmod +w simpleroot28.fs</b>		&lt;--- make sure

</pre>
  <li>You now need to make an ISO image of the entire directory you downloaded.
	I recommend using <b>mkisofs</b> for that purpose. If you don't already
	have mkisofs installed on your system, you need to install that in
	order to do this.<pre>
	$ <b>mkisofs -o openbsd_pmax_2.8.iso ftp.openbsd.org/pub/OpenBSD/2.8/pmax</b>

</pre>
  <li>Start the emulator with all three (!) disk images:<pre>
	$ <b>./mips64emul -D2 -d openbsddisk.img -d b:simpleroot28.fs -j bsd -d c:openbsd_pmax_2.8.iso</b>

</pre>
	(If you add -X, you will run with the graphical framebuffer. This is <i>REALLY</i> slow
	because the console has to scroll a lot during the install. I don't recommend it.)
  <p>
  <li>Go on with the installation as you would do if you were installing on a real machine.
	If you are not used to the OpenBSD installer, then this will most likely
	be a very uncomfortable experience. Some important things to keep in mind are:
	<ul>
	  <li>rz0 is the rootdisk you wish to install onto.
	  <li>rz1 is the simpleroot image.
	  <li>rz2 is the CDROM containing the "install sets".
	  <li>When asked for the "<b>root device?</b>", enter <b>rz1</b>.
	  <li>At "<b>Enter pathname of shell or RETURN for sh:</b>", press enter.
	  <li>At the # prompt, do the following:<pre>
	$ <b>fsck /dev/rz1a</b>        (and mark the filesystem as clean)
	$ <b>mount /dev/rz1a /</b>
	$ <b>mount -t kernfs kern kern</b>
	$ <b>./install</b>

</pre>
		and proceed with the install. Good luck. :-)
	  <li>Answer "<b>y</b>" when asked if you wish to configure the network.
		(See the section about installing NetBSD/pmax for suitable
		network settings.)
	  <li>Install from "<b>c</b>" (cdrom), choose "<b>rz2</b>" as the cdrom device, and "<b>/</b>" as
		the directory containing the install sets.
	</ul>
  <p>
  <li>
For some unknown reason, the install script does not set the root
password! The first time you boot up OpenBSD after the install, you
need to go into single user mode and run <b>passwd root</b> to set
the root password, or you will not be able to log in at all!
<pre>
	$ <b>./mips64emul -D2 -d openbsddisk.img -d 2c:openbsd_pmax_2.8.iso -j bsd -o '-s'</b>
</pre>
While you are at it, you might want to extract the X11 install sets
as well, as the installer seems to ignore them too. (Perhaps due to a bug
in the installer, perhaps because of the way I used mkisofs.)
<p>
Execute the following commands in the emulator:
<pre>
	# <b>fsck /dev/rz0a</b>
	# <b>mount /</b>
	# <b>passwd root</b>

	# <b>cd /</b>
	# <b>mount -t cd9660 /dev/rz2c /mnt</b>
	# <b>sh</b>
	# <b>for a in /mnt/[xX]*; do tar zxvf $a; done</b>
	# <b>ln -s /usr/X11R6/bin/Xcfbpmax /usr/X11R6/bin/X</b>
	# <b>ln -s /dev/fb0 /dev/mouse</b>
	# <b>echo /usr/X11R6/lib >> /etc/ld.so.conf</b>
	# <b>ldconfig</b>

	# <b>sync</b>
	# <b>halt</b>
</pre>
</ol>

<p>
The time required to do a full install (including X11) is about an hour
and a half on a 2.8GHz Xeon PC.

<p>
NOTE: It is also possible to install via ftp instead of using a CDROM image. 
This is not much less awkward, you still need the simpleroot filesystem 
image, and you still have to manually add the X11 install sets and set the 
root password, and so on.

<p>
Once you have completed the installation procedure, the following command
will let you boot from the new rootdisk image:
<pre>
	$ <b>./mips64emul -D2 -X -M64 -d openbsddisk.img -j bsd</b>
</pre>
When asked for which root device to use, enter <b>rz0</b>.
<br>When asked for which terminal type to use, when logging in as root,
enter <b>rcons</b> if you are using the graphical framebuffer,
<b>vt100</b> for text-mode.
<br>Use <b>startx</b> to start X windows.






<p><br>
<a name="openbsdarcinstall"></a>
<h3>How to install OpenBSD/arc in the emulator:</h3>

It is possible to run OpenBSD/arc on an emulated Acer PICA-61 in the
emulator.

<p>
(You should be aware of the fact that OpenBSD for the ARC platform died at 
release 2.3, so this will not give you an up-to-date OpenBSD system.
See
<a href="http://www.openbsd.org/arc.html">http://www.openbsd.org/arc.html</a>
for more information.)

<p>
To install OpenBSD/arc onto an emulated harddisk image, follow these
instructions:

<p>
<ol>
  <li>Compile mips64emul:<pre>
	$ <b>./configure; make</b>

</pre>
  <li>Create an empty harddisk image, which will be the root disk
	that OpenBSD installs itself onto:<pre>
	$ <b>dd if=/dev/zero of=obsd_arc.img bs=1024 count=1 seek=700000</b>

</pre>
  <li>Download the entire arc directory from the ftp server: (approx. 75 MB)<pre>
	$ <b>wget -np -l 0 -r ftp://ftp.se.openbsd.org/pub/OpenBSD/2.3/arc/</b>

</pre>

<!-- TODO: maybe change the mkisofs ... .../pub/OpenBSD/2.3/arc
                       into mkisofs ... .../pub/OpenBSD
only. The default behaviour of the openbsd installer is to look for
files in "/2.3/arc" on the cdrom, not "/".  Verify that this works
before making the change!  -->

  <li>You now need to make an ISO image of the entire directory you downloaded.
	I recommend using <b>mkisofs</b> for that purpose. If you don't already
	have mkisofs installed on your system, you need to install that in
	order to do this.<pre>
	$ <b>mkisofs -o openbsd_arc_2.3.iso ftp.se.openbsd.org/pub/OpenBSD/2.3/arc/</b>

</pre>
  <li>Start the emulator using this command line:<pre>
	$ <b>./mips64emul -X -A2 -d obsd_arc.img -d openbsd_arc_2.3.iso ftp.se.openbsd.org/pub/OpenBSD/2.3/arc/bsd.rd.elf</b>

</pre>
	and proceed like you would do if you were installing OpenBSD
	on a real Acer PICA-61.
</ol>

<p>
Once the install has finished, the following command should let you 
boot from the harddisk image:
<p>
<pre>
	$ <b>./mips64emul -X -A2 -d obsd_arc.img ftp.se.openbsd.org/pub/OpenBSD/2.3/arc/bsd</b>

</pre>





<p><br>
<a name="sprite"></a>
<h3>How to run Sprite for DECstation in the emulator:</h3>

Sprite was a research operating system at the University of Berkeley.
The Unix Heritage Society (TUHS, <a href="http://www.tuhs.org">www.tuhs.org</a>)
has made available a copy of a Sprite harddisk image for a DECstation 5000/200.
If you want to find out more about Sprite in general, read
<a href="http://www.cs.berkeley.edu/projects/sprite/retrospective.html">
http://www.cs.berkeley.edu/projects/sprite/retrospective.html</a>.

<p>
The following instructions should let you run Sprite in the emulator:

<p>
<ol>
  <li>Compile mips64emul:<pre>
	$ <b>./configure; make</b>

</pre>
  <li>Download the Sprite harddisk image using ftp or http:<pre>
	<a href="http://www.es.embnet.org/Services/ftp/misc/TUHS/sprite/ds5000.bt">http://www.es.embnet.org/Services/ftp/misc/TUHS/sprite/ds5000.bt</a>
	or <a href="ftp://ftp.es.embnet.org/misc/TUHS/sprite/ds5000.bt">ftp://ftp.es.embnet.org/misc/TUHS/sprite/ds5000.bt</a>
	83973120 bytes, MD5 = ec84eeeb20fe77b758370d5e312e4a5e

</pre>
  <li>Start the emulator with the following command line:<pre>
	$ <b>./mips64emul -X -D2 -M128 -d ds5000.bt -j vmsprite -o ''</b>

</pre>
</ol>

<p>
The first time you boot up with the disk image, you will be asked a number 
of questions regarding network settings. If you feel like entering correct 
values, then you should use the following:
<p>

<pre>
    Your machine's Ethernet address:    10:20:30:40:50:60
    Your machine's IP:                  10.0.0.1
    Subnet mask:                        0xff000000
    Gateway's Ethernet address:         60:50:40:30:20:10
    Gateway's IP:                       10.0.0.254
</pre>

<p>
Unfortunately, at the end of <a href="http://www.es.embnet.org/Services/ftp/misc/TUHS/sprite/boot.txt">
http://www.es.embnet.org/Services/ftp/misc/TUHS/sprite/boot.txt</a>, the 
following sad statement can be found:
<pre>
    The bootable Sprite image is meant to be a demonstration of Sprite, not
    a robust Sprite system.  There are several missing things, such as 
    floating point and network support.
</pre>

<p>
Once you are logged in as root, running <b>xinit</b> will start the X11 
environment.





<p><br>
<a name="declinux"></a>
<h3>How to install Debian GNU/Linux for DECstation in the emulator:</h3>

The Debian folks have made Linux kernels for DECstation available for download.

<p>
<font color="#ff0000">NOTE: Installing Debian does NOT work yet.
These are preliminary instructions, for how an install might eventually
be done.
</font>

<p>
The following steps should let you install Debian GNU/Linux for DECstation
onto a harddisk image:

<p>
<ol>
  <li>Compile mips64emul:<pre>
	$ <b>./configure; make</b>

</pre>
  <li>Create an empty harddisk image, which will be the root disk
	that Debian installs itself onto:<pre>
	$ <b>dd if=/dev/zero of=debian.img bs=512 count=1 seek=2698060</b>

</pre>
  <li>Download the install kernel:<pre>
	<a href="http://http.us.debian.org/debian/dists/testing/main/installer-mipsel/current/images/r3k-kn02/boot.img">http://http.us.debian.org/debian/dists/testing/main/</a>
	<a href="http://http.us.debian.org/debian/dists/testing/main/installer-mipsel/current/images/r3k-kn02/boot.img">installer-mipsel/current/images/r3k-kn02/boot.img</a>
	4743488 bytes, MD5 = 9b635b50e49fae3df7d853a8290a39d8

</pre>
  <li>For a text-mode installation, start the emulator like this:<pre>
	$ <b>./mips64emul -D2 -M128 -o console=ttyS03 -d debian.img -O boot.img</b>

</pre>
</ol>

<p>
(If you want to, you can try <b>-X</b> instead of '<b>-o console=ttyS03</b>' on
the command line. This will cause Linux to use the graphical framebuffer.
Unfortunately, Linux does not seem to have a driver for the DZ11 keyboard
controller yet, so you cannot interact with the system. You will see the
penguin in the upper lefthand corner :-) and nicely rendered Unicode
characters, but that's about it.)

<p>
You need quite a bit of patience, waiting for the kernel and ramdisk to
uncompress themselves, and for the install program to download parts
of itself via the network. For some strange reason, Linux/DECstation runs
<i>incredibly</i> slow in the emulator, compared to for example NetBSD/pmax.
(When running the Debian installer, don't assume that the whole thing has
crashed, it is probably just really really slow.)

<p>
You need to enter some values during the installation procedure, for example
network settings. Cursor keys are unreliable, so use TAB, SPACE, ENTER,
and alphanumeric keys to be sure about entering correct values.
The following <i>might</i> work:
<pre>
    Language:                         English
    Country or Region:                Denmark  (Sweden doesn't seem to be available?)
    DHCP:                             No, choose "Configure network manually"
    IP address:                       10.0.0.1
    Netmask:                          255.0.0.0
    Gateway:                          10.0.0.254
    Name server addresses:            10.0.0.254
    Country for the archive mirror:   Sweden
    Archive mirror:                   ftp.se.debian.org
    Debian version to install:        testing

    ...:                              Erase entire disk
</pre>

<p>
<font color="#ff0000">2004-09-24 NOTE: The installation dies with
an Oops when running 'fdisk' or 'cfdisk'.
</font>





<p><br>
<a name="mach"></a>
<h3>How to run Mach/PMAX in the emulator:</h3>

<p>
Read the following link if you want to know more about Mach in general:
<a href="http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html">
http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html</a>

<p>
<font color="#ff0000">NOTE: Mach for DECstation requires some files
(called 'startup' and 'emulator') which I haven't been able to find
on the web. Without these, Mach will not get very far. These
installation instructions are preliminary.
</font>

<p>
The following steps should let you experiment with running Mach
for DECstation in the emulator:

<p>
<ol>
  <li>Compile mips64emul: (<b>NOTE: --caches</b>)<pre>
	$ <b>./configure --caches; make</b>

</pre>
  <li>Download the pmax binary distribution for Mach 3.0:<pre>
        <a href="http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release/pmax.tar.Z">http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release/pmax.tar.Z</a>
	7263343 bytes, md5 = f9d76c240a6e169921a1df99ad560cc0

</pre>
  <li>Extract the Mach kernel:<pre>
        $ <b>tar xfvz pmax.tar.Z pmax_mach/special/mach.boot.MK83.STD+ANY</b>

</pre>
  <li>Create an empty disk image:<pre>
	$ <b>dd if=/dev/zero of=disk.img bs=1 count=512 seek=400000000</b>

</pre>
  <li>Load the contents of pmax.tar.Z onto the disk image. This is
	complicated, and should be described in more detail some time.
	For now, use your imagination. (For example using OpenBSD/pmax:
	<i>disklabel -E rz1; newfs -O /dev/rz1a;
	mount /dev/rz1a /mnt; cd /mnt; download pmax.tar.Z using ftp;
	tar xzvf pmax.tar.Z; mv pmax_mach/* .; rmdir pmax_mach;
	mkdir mach_servers;
	cd mach_servers;
	cp ../etc/mach_init .;
	cp ../tests/test_service startup;
	dd if=/dev/zero of=paging_file bs=65536 count=400;
	cd /; sync; umount /mnt</i>)
	<p>
  <li>Start the emulator with the following command:<pre>
	$ <b>./mips64emul -D2 -X -d disk.img pmax_mach/special/mach.boot.MK83.STD+ANY</b>

</pre>
</ol>






<p><br>
<a name="experiments"></a>
<h3>Experiments with other kernels and guest OSes:</h3>

The emulator contains code which tries to emulate the workings of MIPS-like CPUs
and surrounding hardware found in real machines, but no actual MIPS ROM code or
MIPS program code.  You will need some form of program to run in the emulator.
<p>
You can use pre-compiled kernels (for example NetBSD or Linux), ROM images, or other programs
that are in MIPS binary format. A couple of different file formats are supported
(ELF, a.out, ECOFF, SREC, raw binaries).
<p>
As an example, let's say you want to emulate a Silicon Graphics O2 machine.
This machine type is also known as IP32, in the SGI namespace. Let's also
say that you want to run NetBSD on this emulated machine. A pre-compiled kernel
for NetBSD/sgimips can be found here:
<a href="http://ftp.sunet.se/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.gz">
http://ftp.sunet.se/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.gz</a>
<p>
Once you have downloaded the kernel and gunzip'd it, you can try it out in the
emulator like this:
<pre>
	$ <b>./mips64emul -G32 -CR5000 -q netbsd-INSTALL</b>
</pre>
-G signifies that we want SGI emulation, and 32 is the SGI-specific machine type.
-q suppresses debug messages. If everything works like it should, you should see NetBSD's boot messages...
<pre>
	$ <b>./mips64emul -G32 -CR5000 -q netbsd-INSTALL</b>
	zs channel 0 had address 0xbfbd9830
	 [ no symbols available ]
	CPU clock speed = 3.00Mhz
	Copyright (c) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
	    The NetBSD Foundation, Inc.  All rights reserved.
	Copyright (c) 1982, 1986, 1989, 1991, 1993
	    The Regents of the University of California.  All rights reserved.
	
	NetBSD 1.6.2 (RAMDISK) #0: Wed Feb 11 06:38:58 UTC 2004
	    autobuild@tgm.netbsd.org:/autobuild/netbsd-1-6-PATCH002/sgimips/OBJ/autobuild/
	netbsd-1-6-PATCH002/src/sys/arch/sgimips/compile/RAMDISK
	32768 KB memory, 29988 KB free, 0 for ARCS, 1740 KB in 435 buffers
	mainbus0 (root): SGI-IP32 [SGI, 8], 1 processor
	cpu0 at mainbus0: MIPS R5000 CPU (0x2321) Rev. 2.1 with built-in FPU Rev. 1.0
	cpu0: 32KB/32B 2-way set-associative L1 Instruction cache, 48 TLB entries
	cpu0: 32KB/32B 2-way set-associative write-back L1 Data cache
	cpu0: 1024KB/16B direct-mapped write-back L2 Data cache
	crime0 at mainbus0 addr 0x14000000: rev 1.1
	mace0 at mainbus0 addr 0x1f000000
	mace0: isa sts 0
	mace0: isa msk 0
	com0 at mace0 offset 0x390000 intr 4: ns16550a, working fifo
	com0: console
	com1 at mace0 offset 0x398000 intr 4: ns16550a, working fifo
	pckbc0 at mace0 offset 0x320000 intr 5: stub
	lpt0 at mace0 offset 0x380000 intr 4: stub
	mcclock0 at mace0 offset 0x3a0000
	mec0 at mace0 offset 0x280000 intr 3: MAC-110 Ethernet, rev 0
	mec0: station address 00:00:00:00:00:00
	mec0: sorry, this is not a real driver
	macepci0 at mace0 offset 0x80000 intr 7: rev 1
	macepci0: ctrl 0
	pci0 at macepci0 bus 0
	pci0: i/o space, memory space enabled, rd/line, rd/mult, wr/inv ok
	biomask 7f netmask 7f ttymask 7f clockmask ff
	md0: internal 3072 KB image area
	boot device: <unknown>
	root on md0a dumps on md0b
	WARNING: clock gained 28 days -- CHECK AND RESET THE DATE!
	root file system type: ffs
	Terminal type? [vt100] <b>_</b>
</pre>
and after typing vt100 (or just pressing enter), you'll reach NetBSD's install program.
You will not be able to install anything though, as the AHC disk controller isn't
emulated yet.
<p>
To exit the emulator, type CTRL-C to enter the single-step debugger,
and type <b>quit</b>. By typing CTRL-B instead, a CTRL-C is sent to
the emulated program.
<p>
Other operating system kernels can be downloaded from various places.
Here are links to some of the kernels that I usually experiment with.
(The degree to which these work in the emulator varies a lot.)

<p>
<ul>
  <li>DECstation:
    <ul>
      <li><a href="http://www.netbsd.org/Ports/pmax/">NetBSD/pmax</a>:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.gz</a>
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.symbols.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/pmax/binary/kernel/netbsd-INSTALL.symbols.gz</a>
	<br>gunzip the files, and run the emulator with <b>-D2 -q -N -XY2</b>
	for a graphical framebuffer console. Remove <b>-XY2</b> and <b>-N</b> to use serial (stdin/stdout) console.
	Read <a href="#netbsdinstall">this section</a> about how to install NetBSD/pmax onto a harddisk image.
      <p>
      <li><a href="http://www.openbsd.org/pmax.html">OpenBSD/pmax</a>:
	<br><a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/pmax/bsd">ftp://ftp.openbsd.org/pub/OpenBSD/2.8/pmax/bsd</a>
	<br>This is an old OpenBSD kernel in a.out format. Try <b>-D2</b>.
	<br>Read <a href="#openbsdinstall">this section</a> about how to install OpenBSD/pmax onto a harddisk image.
	It's a bit more complicated than installing NetBSD/pmax, but might work.
      <p>
      <li>Linux for DECstation:
	<br>Here is a Debian package containing a Linux 2.4.26 kernel for
		DECstation which supports framebuffer!
	<br><a href="http://ftp.debian.org/debian/pool/main/k/kernel-patch-2.4.26-mips/kernel-image-2.4.26-r3k-kn02_2.4.26-0.040505.1_mipsel.deb">http://ftp.debian.org/debian/pool/main/k/kernel-patch-2.4.26-mips/
	<br>kernel-image-2.4.26-r3k-kn02_2.4.26-0.040505.1_mipsel.deb</a>
	<br>Run the following commands to extract the kernel:<pre>
	<b>ar x kernel-image-2.4.26-r3k-kn02_2.4.26-0.040505.1_mipsel.deb data.tar.gz</b>
	<b>tar xfzv data.tar.gz ./boot/vmlinux-2.4.26-r3k-kn02</b>
	<b>mv boot/vmlinux-* .; rmdir boot</b>
</pre>
	<br>To try with the framebuffer: <b>-D2 -X vmlinux-2.4.26-r3k-kn02</b>
	<br>To try with serial console: <b>-D2 -o 'console=ttyS03' vmlinux-2.4.26-r3k-kn02</b>
	<br>Read <a href="#declinux">this section</a> about how to run a Debian Linux install kernel.
	<br>Here are some older kernels (these don't support framebuffer, I think):
		<a href="http://www.xs4all.nl/~vhouten/mipsel/kernels.html">http://www.xs4all.nl/~vhouten/mipsel/kernels.html</a>
	<br>Note: Make sure you add <b>-CR4400</b> to the command line for
		R4000 kernels, as Linux doesn't autodetect CPU type at runtime.
      <p>
      <li>Sprite:
	<br>The Unix Heritage Society (TUHS, <a href="http://www.tuhs.org">www.tuhs.org</a>)
		has a copy of a harddisk image for a DECstation 5000/200:
		<a href="ftp://ftp.es.embnet.org/misc/TUHS/sprite/ds5000.bt">ftp://ftp.es.embnet.org/misc/TUHS/sprite/ds5000.bt</a>
			(MD5 (ds5000.bt) = ec84eeeb20fe77b758370d5e312e4a5e)
	<br>Read <a href="#sprite">this section</a> for more information
		about running this harddisk image in the emulator.
      <p>
      <li><a href="http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html">Mach</a>:
	<br>Important! Run <b>./configure --caches; make</b>
	<br>Download <a href="http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release/pmax.tar.Z">http://lost-contact.mit.edu/afs/athena/user/d/a/daveg/Info/Links/Mach/src/release/pmax.tar.Z</a>
	<br>tar xfvz pmax.tar.Z pmax_mach/special/mach.boot.MK83.STD+ANY
	<br>./mips64emul -D2 -X pmax_mach/special/mach.boot.MK83.STD+ANY
    </ul>
  </li>

  <p>

  <li>SGI:
    <ul>
      <li><a href="http://www.netbsd.org/Ports/sgimips/">NetBSD/sgimips</a>:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.gz</a>
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.symbols.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/sgimips/binary/kernel/netbsd-INSTALL.symbols.gz</a>
	<br>gunzip, and try running with  <b>-G32 -CR5000</b>,
		or <b>-G22</b> or <b>-G24</b> or <b>-G20</b>.
      <p>
      <li>Linux/SGI:
	<br><a href="http://www.linux-mips.org/~glaurung/">http://www.linux-mips.org/~glaurung/</a>
	<br>Try running with <b>-G32 -q</b>. You need to add <b>-CR5000</b> or
		<b>-CR10000</b> to select a specific CPU type, as Linux
		doesn't autodetect CPU at runtime, and <b>-X</b> for a graphical
		framebuffer.
      <p>
      <li><a href="http://www.openbsd.org/sgi.html">OpenBSD/sgi</a>:
	<br>Snapshots can be found at <a href="ftp://ftp.OpenBSD.org/pub/OpenBSD/snapshots/sgi/">ftp://ftp.OpenBSD.org/pub/OpenBSD/snapshots/sgi/</a>.
		Try running the bsd.rd kernel with <b>-G32</b>.
      <p>
      <li><a href="http://www.freebsd.org/platforms/mips.html">FreeBSD/MIPS</a>:
		I don't think public snapshots are available yet.
      <p>
      <li>arcdiag:
	<br>The NetBSD people have also made available an "arcdiag" for SGI-IP22:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/arch/sgimips/arcdiag.ip22">ftp://ftp.netbsd.org/pub/NetBSD/arch/sgimips/arcdiag.ip22</a>
	<br>Try running with <b>-G22 arcdiag.ip22</b>.
    </ul>
  </li>

  <p>

  <li>ARC:
    <ul>
      <li><a href="http://www.netbsd.org/Ports/arc/">NetBSD/arc</a>:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd.RAMDISK.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd.RAMDISK.gz</a>
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd.RAMDISK.symbols.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/arc/binary/kernel/netbsd.RAMDISK.symbols.gz</a>
	<br>gunzip, and try with <b>-A1</b> (NEC RISCstation 2250, add <b>-X -N</b> for a graphical framebuffer),
		<b>-A3</b> (NEC RISCstation 2200),
	<br><b>-A2</b> (Acer PICA-61), <b>-X -A4</b> (Deskstation Tyne), or <b>-A5</b> (Microsoft Jazz, MIPS Magnum)
	<br>Read <a href="#netbsdarcinstall">this section</a> about how
		to install NetBSD/arc onto a harddisk image.
      <p>
      <li><a href="http://www.openbsd.org/arc.html">OpenBSD/arc</a>:
	<br><a href="ftp://ftp.se.openbsd.org/pub/OpenBSD/2.3/arc/bsd.rd.elf">ftp://ftp.se.openbsd.org/pub/OpenBSD/2.3/arc/bsd.rd.elf</a>
	<br>Try running with <b>-X -A2</b> or <b>-X -A4</b>.
	<br>Read <a href="#openbsdarcinstall">this section</a> about how
		to install OpenBSD/arc onto a harddisk image.
      <p>
      <li>Linux:
	<br><a href="ftp://ftp.linux-mips.org/pub/linux/mips/mipsel-linux/boot/vmlinux-m700-2.1.131.gz">ftp://ftp.linux-mips.org/pub/linux/mips/mipsel-linux/boot/vmlinux-m700-2.1.131.gz</a>
	<br>gunzip, and run with <b>-v -X -N -A7</b> (Olivetti M700)
      <p>
      <li>Pandora:
	<br><a href="ftp://ftp.linux-mips.org/pub/linux/mips/ancient/milo/">ftp://ftp.linux-mips.org/pub/linux/mips/ancient/milo</a>/<a href="ftp://ftp.linux-mips.org/pub/linux/mips/ancient/milo/milo-0.27.1.tar.gz">milo-0.27.1.tar.gz</a>
	<br>A generic test/diagnostics program for ARC-based machines.
	<br>Run with <b>-A4 milo-0.27.1/pandora</b>
      <p>
      <li>arcdiag:
	<br>Precompiled binary:<a href="ftp://ftp.netbsd.org/pub/NetBSD/arch/arc/arcdiag">ftp://ftp.netbsd.org/pub/NetBSD/arch/arc/arcdiag</a>
	<br>(alternative: <a href="http://www.sensi.org/~alec/mips/arcdiag">http://www.sensi.org/~alec/mips/arcdiag</a>)
	<br>A generic test/diagnostics program for ARC-based machines.
	<br>Run with <b>-A1 arcdiag</b> (or <b>-A2</b> etc).
	<br>Example arcdiag output (from real machines):
	<br><a href="http://mail-index.netbsd.org/port-arc/2000/10/18/0001.html">http://mail-index.netbsd.org/port-arc/2000/10/18/0001.html</a> (Olivetti M700-10)
	<br><a href="http://www.sensi.org/~alec/mips/arcdiag.txt">http://www.sensi.org/~alec/mips/arcdiag.txt</a> (PICA-61)
	<br><a href="http://mail-index.netbsd.org/port-arc/2000/10/14/0000.html">http://mail-index.netbsd.org/port-arc/2000/10/14/0000.html</a> (Deskstation Tyne)
	<br><a href="http://mail-index.netbsd.org/port-arc/2004/02/01/0001.html">http://mail-index.netbsd.org/port-arc/2004/02/01/0001.html</a> (NEC RISCserver 4200)
    </ul>
  </li>

  <p>

  <li>Cobalt:
    <ul>
      <li><a href="http://www.netbsd.org/Ports/cobalt/">NetBSD/cobalt</a>:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/cobalt/binary/kernel/netbsd-GENERIC.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6.2/cobalt/binary/kernel/netbsd-GENERIC.gz</a>
	<br>gunzip, and run with <b>-E</b>
      <p>
      <li>Linux:
	<br><a href="http://people.debian.org/~pm/mips-cobalt/nfsroot/vmlinux_raq-2800.gz">http://people.debian.org/~pm/mips-cobalt/nfsroot/vmlinux_raq-2800.gz</a>
	<br>gunzip, and run with <b>-E</b>
    </ul>
  </li>

  <p>

  <li>Playstation 2:
    <ul>
      <li><a href="http://www.netbsd.org/Ports/playstation2/">NetBSD/playstation2</a>:
	<br>A NetBSD/playstation2 snapshot kernels are available here: (RAMDISK and GENERIC)
	<br><a href="ftp://ftp.NetBSD.org/pub/NetBSD/arch/playstation2/snapshot/20020327/installation/netbsd.gz">ftp://ftp.NetBSD.org/pub/NetBSD/arch/playstation2/snapshot/20020327/installation/netbsd.gz</a>
	<br><a href="ftp://ftp.NetBSD.org/pub/NetBSD/arch/playstation2/snapshot/20020327/binary/kernel/netbsd-GENERIC.gz">ftp://ftp.NetBSD.org/pub/NetBSD/arch/playstation2/snapshot/20020327/binary/kernel/netbsd-GENERIC.gz</a>
	<br>Try running with <b>-XBN</b>  (<b>-X</b> is required, for the framebuffer).

      <p>
      <li>Linux:
	<br>A Linux kernel (2.2.21-pre1-xr7) is available from
	<a href="http://playstation2-linux.com/projects/xrhino-kernel/">http://playstation2-linux.com/projects/xrhino-kernel/</a>
	<br>Try running with <b>-XBN</b>  (<b>-X</b> is required, for the framebuffer).
    </ul>
  </li>

  <p>

  <li>Sony NeWS:
    <ul>
      <li><a href="http://www.netbsd.org/Ports/newsmips/">NetBSD/newsmips</a>:
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6/newsmips/binary/kernel/netbsd.INSTALL.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6/newsmips/binary/kernel/netbsd.INSTALL.gz</a>
	<br><a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6/newsmips/binary/kernel/netbsd.INSTALL.symbols.gz">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6/newsmips/binary/kernel/netbsd.INSTALL.symbols.gz</a>
	<br>(<a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6/newsmips/installation/floppy/boot.fs">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.6/newsmips/installation/floppy/boot.fs</a>)
	<br>Try running with <b>-f</b>.
    </ul>
  </li>

  <p>

  <li><a href="http://www.meshcube.org/">MeshCube</a>:
    <ul>
      <li>Linux:
	<br>A Linux kernel is available from
	<a href="http://www.meshcube.org/feed/stable/">http://www.meshcube.org/feed/stable</a>/<a href="http://www.meshcube.org/feed/stable/kernel-image-mtx_2.4.24-3_mipsel.ipk">kernel-image-mtx_2.4.24-3_mipsel.ipk</a>
	<br>(This is a Debian package, you can use <b>ar</b> and <b>tar</b>
		to extract kernel.img from it.)
	<br>Try running with <b>-e 0x80800000:kernel.img</b>.
    </ul>
  </li>

  <p>

  <li><a href="http://www.seattlewireless.net/index.cgi/NetgearWG602">NetGear WG602</a>:
    <ul>
      <li>Linux:
	<br>A Linux kernel is available from
	<a href="ftp://downloads.netgear.com/files/wg602_v1715.zip">ftp://downloads.netgear.com/files/wg602_v1715.zip</a>
	<br>(Unzip wg602_v1715.zip to get WG602_V1715.img.)
	<br>Try running with <b>-g 0xbfc80000:0x40:WG602_V1715.img</b>.
	<br>(It takes some time to decompress the kernel, so be patient.)
    </ul>
  </li>

  <p>

  <li>Linksys WRT54G
    <ul>
      <li>Linux:
	<br><a href="http://openwrt.org/">OpenWRT</a> is a Linux
		distribution for the WRT54G.
	<br><a href="http://www.batbox.org/wrt54g-linux.html">BatBox</a>
		is another distribution.
	<br>Download <a href="http://pjf.dotgeek.org/downloads/openwrt/openwrt-g-code.bin">http://pjf.dotgeek.org/downloads/openwrt/openwrt-g-code.bin</a>
		(or a similar .bin file).
	<br>From offset 60 and forward in the bin file, there is a gzip file.
	<br>$ <b>dd if=openwrt-g-code.bin of=piggy.gz bs=60 iseek=1 oseek=0</b>
	<br>$ <b>gunzip piggy.gz</b>
	<br>$ <b>./mips64emul -H -t 0x80001000:piggy</b>
	<br>There's also a .bin file available from linksys:
		<a href="ftp://ftp.linksys.com/pub/network/WRT54G_1.30.7_US_code.bin">ftp://ftp.linksys.com/pub/network/WRT54G_1.30.7_US_code.bin</a>
    </ul>
  </li>

</ul>




<p><br>
<a name="fbres"></a>
<h3>Changing the framebuffer resolution:</h3>

Running the emulator with the <b>-X</b> option turns on the X11 framebuffer.
If the framebuffer device for the specific machine mode you are running is
implemented well enough, then the framebuffer window will look exactly like
the real machine's screen, pixel by pixel.
<p>
For many emulated graphics cards in the emulator (or emulation modes), the
resolution is fixed. It is possible in some emulation modes, however, to change
cards completely. The TURBOchannel cards on some of the emulated DECstation
models support this. (The -D2 model is luckily one of these models.)
This is not implemented as a command-line option yet, so you have to modify
the source code to do this.
<p>
The <i>turbochannel_default_gfx_card</i> string defines
the name of the graphics card. Look in src/machine.c for this line:
<p>
<pre>
	<b>char *turbochannel_default_gfx_card = "PMAG-BA";</b>
</pre>
<p>
Different cards have different resolution.
<p>
<center><table border="0">
  <tr>
    <td><u><b>Card name:</b></u></td>
    <td><u><b>Resolution:</b></u></td>
    <td><u><b>Color depth:</b></u></td>
    <td><u><b>Comments:</b></u></td>
  </tr>
  <tr>
    <td>PMAG-AA</td>
    <td>1280 x 1024</td>
    <td>B/W</td>
    <td>(perhaps problems with the cursor?)</td>
  </tr>
  <tr>
    <td>PMAG-BA</td>
    <td>1024 x 864</td>
    <td>8-bit color</td>
    <td>Works fine in OpenBSD, NetBSD, Ultrix, Linux, Sprite</td>
  </tr>
  <tr>
    <td>PMAGB-BA</td>
    <td>1280 x 1024</td>
    <td>8-bit color</td>
    <td>Works fine in OpenBSD, NetBSD, Linux, Sprite</td>
  </tr>
  <tr>
    <td valign="top">PMAG-FA</td>
    <td valign="top">1280 x 1024</td>
    <td valign="top">8/24-bit</td>
    <td>Works fine in text-mode only with NetBSD and Ultrix,
	<br>(3D acceleration is not emulated)</td>
  </tr>
</table></center>
<p>
If the framebuffer window is too large, is is possible to scale it down
by adding <b>-Y2</b> to the command line.





<p><br>
<a name="networking"></a>
<h3>Networking:</h3>

It is possible to let the guest OS running inside the emulator get access to
the Internet. If you are interested in the technical details, and the 
reasons why networking is implemented in the emulator the way it currently 
is implemented, you might want to read the <a href="technical.html#net">
networking section in the technical documentation</a>.
<p>
The guest OS running inside the emulator uses a private IPv4 address, such
as 10.0.0.1, and the emulator acts as a NAT-like gateway/firewall at IPv4
address 10.0.0.254. To the outside world it will seem like it is the host's
OS that connects to other machines on the internet, not the guest OS.
<p>
<font color="#ff0000">NOTE: This is still experimental!
As of 2004-07-21, ARP + ICMP + UDP + TCP are emulated well enough to let 
NetBSD and OpenBSD install via ftp, and use the network for many normal 
activities, but not everything works yet.</font>



<p><br>
<a name="hello"></a>
<h3>Hello world:</h3>

You might want to use the emulator to develop programs on your own,
not just run precompiled kernels such as NetBSD. To get started, I'd recommend
you do two things:
<ul>
  <li>Build and install a cross-compiler for MIPS.
  <li>Compile this hello world program, and run it in the emulator.
</ul>
<p>
If the emulator is launched without specifying which machine to emulate,
it will emulate only a CPU and very few devices. One of those devices
is a console putchar() device, at a fixed address.
<pre>
	/*  Hello world for mips64emul  */

	#define	PUTCHAR_ADDRESS		0xb0000000

	void printchar(char ch)
	{
		*((volatile unsigned char *) PUTCHAR_ADDRESS) = ch;
	}

	void printstr(char *s)
	{
		while (*s)
			printchar(*s++);
	}

	void f(void)
	{
		printstr("Hello world\n");
		for (;;)
			;
	}
</pre>
This hello world program is available here as well: <a href="hello.c">hello.c</a>
<p>
I'd recommend you build a GCC cross compiler for the <b>mips64-unknown-elf</b>
target, and install it. Other compilers might work too, but GCC is good because
of its portability. Then try to compile the hello world program:
<pre>
	$ <b>mips64-unknown-elf-gcc hello.c -mips4 -mabi=64 -c</b>
	$ <b>mips64-unknown-elf-ld -Ttext 0x80030000 -e f hello.o -o hello --oformat=elf64-bigmips</b>
	$ <b>file hello</b>
	hello: ELF 64-bit MSB mips-4 executable, MIPS R3000_BE, version 1 (SYSV), statically linked, not stripped
	$ <b>./mips64emul -q hello</b>
	Hello world

	$ <b>mips64-unknown-elf-gcc hello.c -c</b>
	$ <b>mips64-unknown-elf-ld -Ttext 0x80030000 -e f hello.o -o hello</b>
	$ <b>file hello</b>
	hello: ELF 32-bit MSB mips-3 executable, MIPS R3000_BE, version 1 (SYSV), statically linked, not stripped
	$ <b>./mips64emul -q hello</b>
	Hello world
</pre>
As you can see above, a GCC configured for mips64-unknown-elf can produce
both 64-bit and 32-bit binaries.
<p>
Hopefully this is enough to get you inspired. :-)


<p><br>
<a name="portmips"></a>
<h3>Porting operating systems to MIPS using mips64emul:</h3>

Is this a good idea?  The answer is yes and no, depending on what you are
trying to port to. If you are developing an operating system or operating
system kernel of your own, and wish to target MIPS-like systems in general,
then the answer might be yes, for experimental purposes.
<p>
However, if you think that you can port an operating system
to, say, the Silicon Graphics machine mode of mips64emul and hope that your
operating system will run on a real SGI machine, then you will most
likely fail. mips64emul simply does not emulate things well enough for that to work.
Another example would be specific CPU details; if your code depends on,
say, R10000 specifics, chances are that mips64emul will not be sufficient.
<p>
In many cases, hardware devices in mips64emul are only implemented well
enough to fool for example NetBSD that they are working correctly, while in fact
they don't work very much at all.  Please keep this in mind, if you plan
to use mips64emul when porting your code to MIPS.


<p><br>
<a name="disk"></a>
<h3>How to start the emulator with a disk image:</h3>

Add <i>-d [prefixes:]diskimagefilename</i> to the command line, where prefixes
are one or more single-character options. Run mips64emul with no command line
arguments to get a list of possible options.
<p>
Here are some examples. If you want to run a NetBSD/pmax kernel on an
emulated DECstation machine, you would use a command line such as this:
<pre>
	$ <b>./mips64emul -D2 -d pmax_diskimage.fs netbsd-pmax-INSTALL</b>
</pre>
<p>
NOTE: For some emulation modes, such as the DECstation mode, you do 
<i>not</i> have to specify the name of the kernel, if the disk image is 
bootable!
<p>
It is possible to have more than one disk. For each -d argument, a disk
image is added; the first will be SCSI target 0, the second will be target 1, and so on,
unless you specify explicitly which ID number the devices should have.
<pre>
	$ <b>./mips64emul -D2 -d disk0.raw -d disk1.raw -d 5:disk2.raw netbsd-pmax-INSTALL</b>
</pre>
Note: In the example above, disk2.raw will get scsi id 5.
<p>
If a filename has a 'c' prefix, or ends with ".iso", then it is assumed to be
a CDROM device (this can be overridden with a 'd' prefix, to force a read/write disk).
For example, the following command would start the emulator with two
CDROM images, and one harddisk image:
<pre>
	$ <b>./mips64emul -D2 -d image.iso -d disk0.img -d C:second_cdrom.img netbsd-pmax-INSTALL</b>
</pre>
Usually, the device with the lowest id becomes the boot device. To override
this, add a 'b' prefix to one of the devices:
<pre>
	$ <b>./mips64emul -D2 -d rootdisk.img -d bc:install-cd.iso name_of_kernel</b>
</pre>
If you have a physical CD-ROM drive on the host machine, say /dev/cd0c, you can
use it as a CD-ROM directly accessible from within the emulator:
<pre>
	$ <b>./mips64emul -D2 -d rootdisk.img -d bc:/dev/cd0c name_of_kernel</b>
</pre>
It is probably possible to use harddisks as well this way, but I would not
recommend it.
<p>
Using emulated tape drives is a bit more complicated than disks, because a
tape can be made up of several "files" with space in between. The solution
I have choosen is to have one file in the host's file system space for each
tape file. The prefix for using tapes is 't', and the filename given is
for the <i>first</i> file on that tape (number zero, implicitly). For
files following file nr 0, a dot and the filenumber is appended to the
filename.
<p>
As an example, starting the emulator with
<pre>
	<b>-d t4:mytape.img</b>
</pre>
will cause SCSI id 4 to be a tape device, using the following file number
to name translation scheme:
<p>
<center>
 <table border="0">
  <tr>
    <td><b>File number:</b></td>
    <td><b>File name in the host's filesystem:</b></td>
  </tr>
  <tr>
    <td align="center">0</td>
    <td align="left">mytape.img</td>
  </tr>
  <tr>
    <td align="center">1</td>
    <td align="left">mytape.img.1</td>
  </tr>
  <tr>
    <td align="center">2</td>
    <td align="left">mytape.img.2</td>
  </tr>
  <tr>
    <td align="center">..</td>
    <td align="left">..</td>
  </tr>
 </table>
</center>
<p>
If you already have a number of tape files, which should be placed on the
same emulated tape, then you might not want to rename all those files.
Use symbolic links instead (ln -s).
<p>
There is another advantage to using symbolic links for tape filenames:
every time a tape is rewound, it is reopened using the filename given
on the command line. By changing what the symbolic name points to,
you can "switch tapes" without quiting and restarting the emulator.



<p><br>
<a name="largeimages"></a>
<h3>How to extract large gzipped disk images:</h3>

Unix filesystems usually support large files with "holes". Holes are 
zero-filled blocks that don't actually exist on disk. This is very 
practical for emulated disk images, as it is possible to create a very 
large disk image without using up much space at all.

<p>
Using gzip and gunzip on disk images can be <i>very</i> slow, as these 
files can be multiple gigabytes large, but this is usually neccessary for
transfering disk images over the internet. If you receive a gzipped disk 
image, say disk.img.gz, and run a naive
<p>
<pre>
	$ <b>gunzip disk.img.gz</b>
</pre>
<p>
on it, you will not end up with an optimized file unless 
gunzip supports that. (In my experiments, it doesn't.)  In plain English, 
if you type <b>ls -l</b> and the filesize is 9 GB, it will actually occupy 
9 GB of disk space! This is often unacceptable.
<p>
Using a simple tool which only writes blocks that are non-zero, a lot of 
space can be saved. Compile the program cp_removeblocks in the 
experiments/ directory, and type:
<p>
<pre>
	$ <b>gunzip -c disk.img.gz | ./cp_removeblocks /dev/stdin disk.img</b>
</pre>

<p>
This will give you a disk.img which looks like it is 9 GB, and works like
the real file, but the holes are not written out to the disk. (You can see
this by running for example <b>du disk.img</b> to see the physical block
count.)



<p><br>
<a name="userland"></a>
<h3>Running userland binaries:</h3>

You can run (some) userland programs as well. This will not emulate any
particular machine, but instead try to translate syscalls from for example
NetBSD/pmax into the host's OS' syscalls. For this to work, you have
to add <b>--userland</b> to the command line when running ./configure.

<p>
For example, running /bin/hostname
or /bin/date and similarly trivial programs from the NetBSD/pmax distribution
works:
<pre>
	$ <b>./mips64emul -qu1 pmax_bin_hostname</b>
	tab.csbnet.se
	$ <b>./mips64emul -qu1 pmax_bin_date</b>
	Sun Jan 25 02:26:14 GMT 2004
	$ <b>./mips64emul -qu1 pmax_bin_sleep</b>
	usage: pmax_bin_sleep seconds
	$ <b>./mips64emul -qu1 pmax_bin_sleep 5</b>
	$ <b>./mips64emul -qu1 pmax_bin_sync</b>
</pre>
There's also an Ultrix4 emulation mode:
<pre>
	$ <b>./mips64emul -qu2 ultrix4_bin_date</b>
	UNIMPLEMENTED ultrix syscall 54
	UNIMPLEMENTED ultrix syscall 62
	Mon Feb  9 12:50:59 WET 2004
	$ <b>./mips64emul -qu2 ultrix4_bin_hostname</b>
	tab.csbnet.se
</pre>
NOTE: Userland syscall emulation is still in its beginning stages, so almost
nothing works. It's mostly a proof-of-concept implementation, to show that 
such cross-platform userland emulation is possible.
<p>
IRIX userland emulation might theoretically also be possible to add.


<p><br>
<a name="decrom"></a>
<h3>Using a PROM image from a DECstation:</h3>

<i>(The general ideas in this section applies to using ROM images from other machines as well.)</i>
<p>
Raw PROM images from real machines can, in a few cases, be used. One
case which I've tried is to use a DECstation 5000/125 PROM image.
ROM images from other machines might work as well, but ROM code is
usually much more sensitive to correctness of the emulator than
operating system kernels or userland programs are.
<p>
The image first needs to be extracted from the machine. I presume
that these PROMs are not legal to redistribute, so you really need
to extract the PROM from a physical machine that you own. There are
several ways to do this.
<ul>
  <li>Use hardware to read the PROM chip(s) directly. Not easy if you
	don't have such a hardware reader.
  <li>Copy the PROM memory range into a file, from a running
	operating system. You need a running OS, and it must
	have access to the PROM memory range. NetBSD, for example,
	doesn't allow that from userland.
  <li>Hook up a serial console and dump using the PROM's own dump
	command.
</ul>
<p>
The easiest way is to hook up a serial console. The terminal must be
able to capture output to a file.
<p>
These are approximately the commands that I used:
<pre>
        >><b>cnfg</b>                             <i>Show machine configuration</i>

        >><b>printenv</b>                         <i>Show environment variables</i>

        >><b>setenv more 0</b>                    <i>This turns off the More messages</i>

        >><b>e -x 0xbfc00000:0xbfffffff</b>       <i>Dump the PROM data</i>
</pre>
<p>
Remember that DECstation are little endian, so if the dump data
looks like this:
<pre>
        bfc00000:  0x0bf0007e
</pre>
then the bytes in memory are actually 0x7e, 0x00, 0xf0, and 0x0b.
<p>
At 9600 bps, about 10KB can be dumped per minute, so it takes a while.
Once enough of the PROM has been dumped, you can press CTRL-C to break out.
Then, restore the more environment variable:
<pre>
        >><b>setenv more 24</b>
</pre>
<p>
Now, convert the data you just saved (little-endian words -> bytes),
and store in a file. Let's call this file DECstation5000_125_promdump.bin.
<pre>
        $ <b>./decprom_dump_txt_to_bin DECstation5000_125_promdump.txt DECstation5000_125_promdump.bin</b>
</pre>
This binary image can now be used in the emulator:
<pre>
	$ <b>./mips64emul -D3 -Q -M128 -q 0xbfc00000:DECstation5000_125_promdump.bin</b>

	KN02-BA V5.7e   
	?TFL:  3/scc/access (1:Ln1 reg-12: actual=0x00 xpctd=0x01) [KN02-BA]
	?TFL:  3/scc/io (1:Ln0 tx bfr not empty. status=0X 0) [KN02-BA]
	...
	--More--?TFL: 3/scsi/cntl (CUX, cause= 1000002C)
	>><b>?</b>
	 ? [cmd]
	 boot [[-z #] [-n] #/path [ARG...]]
	 cat SCRPT
	 cnfg [#]
	 d [-bhw] [-S #] RNG VAL
	 e [-bhwcdoux] [-S #] RNG
	 erl [-c]
	 go [ADR]
	 init [#] [-m] [ARG...]
	 ls [#]
	 passwd [-c] [-s]
	 printenv [EVN]
	 restart
	 script SCRPT
	 setenv EVN STR
	 sh [-belvS] [SCRPT] [ARG..]
	 t [-l] #/STR [ARG..]
	 unsetenv EVN
	>><b>cnfg</b>
	 3: KN02-BA  DEC      V5.7e    TCF0  (128 MB)
	                                     (enet: 00-00-00-00-00-00)
	                                     (SCSI = 7)
	 0: PMAG-BA  DEC      V5.3a    TCF0
	>><b>printenv</b>
	 boot=
	 testaction=q
	 haltaction=h
	 more=24
	 #=3
	 console=*
	 osconsole=3
	>>
</pre>
<i>(Note: at the moment, this doesn't work. I must have broken something when
fixing something else, but this is what it looked like at the time.)</i>
<p>
During bootup, the PROM complains <i>a lot</i> about hardware failures.
That's because the emulator doesn't emulate the hardware well enough yet.
<p>
The command line options used are:
-D3 for DECstation model 3 (5000/xxx), -Q to supress the emulator's own PROM
call emulation, -M128 for 128MB RAM (because mips64emul doesn't correctly
emulate memory detection well enough for the PROM to accept, so it will
always believe there is 128MB ram anyway), and -q to supress debug messages.
The 0xbfc00000 in front of the filename tells mips64emul that it is a raw
binary file which should be loaded at a specific virtual address.


<p><br>
<a name="feedback"></a>
<h3>Feedback:</h3>

If you have comments, don't hesitate to mail me at
md1gavan @mdstud.chalmers.se.




</body>
</html>
