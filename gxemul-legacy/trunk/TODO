$Id: TODO,v 1.217 2006-02-25 18:30:31 debug Exp $

Hm. This file is in random order, and not all parts of it are up-to-date.

Dyntrans:
	x)  MIPS fast load/store:  endianness, alignment check
	x)  PPC 64-bit loads/stores
	x)  Delay slots!
	x)  Old MIPS -> dyntrans!
	x)  INVALIDATION should cause translations in _all_ cpus to be
	    invalidated, e.g. on a write to a write-protected page
	    (containing code)
	x)  better (meaningful) instr call statistics
	x)  Call/return hints?
	x)  16-bit encodings? (MIPS16, ARM Thumb, SH3, ...)
	x)  PPC optimizations; instr combs
	x)  Alpha
	x)  SPARC
	x)  PPC (64-bit stuff)
	x)  Lots of other stuff: see src/cpus/README_DYNTRANS
	x)  true recompilation backend? think carefully about this,
	    experiment in a separate project (not in GXemul)

Algor:	PCI and ISA and LOCAL interrupts! --> wdc could start working
	Add interrupt controller in dev_algor.c.

AVR:
	o)  first 0x60 bytes of SRAM area should be mapped to registers
	    etc using a device!

ARM:
	o)  add ID for "i80321 600MHz rev 2 (XScale core)"
	o)  try to get netbsd/evbarm 3.x running (iq80321)
	o)  make the ata controller usable for FreeBSD!
	o)  zaurus for openbsd...
	o)  debian/cats crashes because of unimplemented coproc stuff.
	    fix this?

Cache simulation:
	o)  Separate from the CPU concept, so that multi-core CPUs sharing
	    e.g. a L2 cache can be simulated (?)
	o)  Instruction cache emulation is easiest (if separate from the
	    data cache); similar hack as the S;I; hack in cpu_dyntrans.c.
	o)  Data cache emulation = harder; each arch's load/store routines
	    must include support?

Documentation:
	o)  Try to rewrite the install instructions for those machines
	    that use 3MAX into using CATS? (To remove the need to a raw
	    ffs partition using up all of the disk image.)

More generic out_of_memory error reporting, and check everywhere!
	Causes:	OpenBSD has low default limits for normal users.
		Host is 32-bit? (32-bit hosts are limited to 4 GB or less
		of userspace memory.)
		You are actually low on RAM. (As trivial as this might sound,
		Unix systems usually allow processes to allocate virtual
		memory beyond the amount of RAM in the machine.)

Breakpoints: 32-bit vs 64-bit sign extension for MIPS, warnings, etc.
	Use the debugger's symbolic name stuff. (which will have to be
	extended soon to support stuff like  "2*x + symbol + y" etc. cool
	stuff)

Sprite (guest OS for DECstation emulation)
	x)  Timing problems during bootup?

The Device subsystem:
	x)  allow devices to be moved and/or changed in size (down to a
	    minimum size, etc, or up to a max size)
	x)  keep track of interrupts and busses? actually, allowing any device
	    to be a bus might be a nice idea.
	x)  turn interrupt controllers into devices? :-)
	x)  refactor various clocks/nvram/cmos into one device?

Clocks:
	x)  General framework for automagic clock adjustment for _all_
	    kinds of clocks and timers. (Which should be possible to turn
	    off, of course, like the way DECstation emulation works now.)

PCI:
	x)  add support for address fixups
	x)  generalize the interrupt routing stuff (lines etc). this should
	    be per machine? or per bus, that's better

MacPPC:
	x)  dev_zs / interrupts?
	x)  adb controller; keyboard
	x)  make OpenBSD/macppc work (PCI controller stuff)

Network layer:
	o)  DHCP (for Debian and BSD installers :-)
	o)  increase performance
	o)  don't rely on NetBSD-ish usage
	o)  Multiple networks per emulation, and let different
	    NICs in machines connect to different networks.
	o)  many other issues: see src/net.c

Busses:
	o)  Redesign the entire "mainbus" concept!
	o)  Busses should be placed in a hierarchical tree!
	o)  Easily configurable interrupt routing in SMP systems.
	o)  Specific clock/bus speeds, cpu speeds etc.
	o)  Synchronization over network? or at least in dyntrans within
	    one emulated machine
	o)  dev->bus: TurboChannel, PCMCIA, ADB?

Config file parser:
	o)  Refresh/rewrite it :)
	o)  Usage of any expression available through the debugger
	o)  Expressions such as "add device" would be nice to be able
	    to do on the command line manually.
	o)  Allow machine() entries even if there is no emul() entry (but
	    then don't allow any emul() entries at all).
	o)  Support for running debugger commands (like the -c
	    command line option)

Floating point layer:
	o)  make it common enough to be used by _all_ emulation modes
	o)  implement more stuff
	o)  non-IEEE modes (i.e. x86)?

Userland emulation:
	x)  Lots of stuff; freebsd and netbsd (and linux?) syscalls.
	x)  Dynamic linking? Hm.

Sound:
	x)  generic sound framework
	x)  add one or more sound cards as devices

ASC SCSI controller:
	x)  NetBSD/arc 2.0 uses the ASC controller in a way which GXemul
	    cannot yet handle. (NetBSD 1.6.2 works ok.) (Possibly a problem
	    in NetBSD itself, http://mail-index.netbsd.org/source-changes/
	    2005/11/06/0024.html suggests that.)

Caches / memory hierarchies: (this is mostly MIPS-specific)
	o)  MIPS coproc.c: bits in config registers should reflect
	    correct cache sizes for _all_ CPU types. (currently only
	    implemented for R4000, R1x000, and a few others)
	o)  src/memory*.c: Implement correct cache emulation for
	    all CPU types. (currently only R2000/R3000 is implemented)
	    (per CPU, multiple levels should be possible,
	    associativity etc!)
	o)  R2000/R3000 isn't _100%_ correct, just almost correct :)
	o)  Move the -S (fill mem with random) functionality into the
	    memory.c subsystem, not machine.c or wherever it is now
	o)  ECC stuff, simulation of memory errors?  (Machine dependent)
	o)  More than 4GB of emulated RAM, when run on a 32-bit host?
	    (using manual swap-out of blocks to disk, ugly)
	o)  A global command line option should be used to turn
	    cache emulation on or off. When off, caches should be
	    faked like they are right now. When on, caches and
	    memory latencies should be emulated as correctly as
	    possible.

MIPS CPU emulation:  (note: this is for the OLD mips stuff)
	o)  i386 bintrans backend: movn etc, slt[u] for
		64-bit mode, 64-bit shifts etc
	o)  Instructions:
		o)  All ISAs:
			o)  Floating point exception handling, and
				add more instructions.
			o)  Finish the MIPS16 translator, and test it!
			o)  MIPS ISA I, II, III, IV
			o)  MIPS V (SIMD vector stuff?)
			o)  MDMX  (MIPS Digital Media Extension)
			o)  MIPS 3D
			o)  MIPS MT (Multi-thread stuff) (What's this?)
		o)  Warn about mis-used bit fields (ie bits that
		    should be all zeroes, warn about if they are not)!
		    Both for coprocessor registers and for instruction
		    opcodes.
		o)  the special2 stuff is a mess right now
		o)  warn and/or cause exceptions for unimplemented
		    instructions (depending on CPU type)
	o)  R2000/R3000:
		x)  R3000 "tri-byte stores". (What's this?)
	o)  R4000 and others:
		x)  watchhi/watchlo exceptions, and other exception
		    handling details
	o)  R10000 and others:  (R12000, R14000 ?)
		x)  memory space, exceptions, ...
		x)  use cop0 framemask for tlb lookups
		    (http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/hdwr/bks/SGI_Developer/books/R10K_UM/sgi_html/t5.Ver.2.0.book_284.html)
	o)  Implement load delays?  Warnings on interlocks.
	o)  Implement all coprocessor 0 bits / functions.
		x)  coproc 0 selectors! (R4000 ?)
	o)  R4300 (nintendo64, no mmu?), R5900 (playstation2, weird
		TLB/cache? 128-bit GPRs, new instructions),
		4K (note: NOT R4000), 5K (note: NOT R5000),
		R6000 (ISA II), R8000
	o)  Multi-cpu stuff:
		+)  Interrupt routing (ie devices vs mainbus, or
		    connect each device to a fixed cpu)
		+)  SGI's NUMA architecture. Study
			x)  Linux sources
			x)  SGI's specs on NUMA address space
		+)  Ultrix?  NetBSD doesn't do SMP on MIPS yet :-(
		+)  Own experiments with ycx2.

File/disk/symbol handling:
	o)  Better handling of tape files
	o)  Read function argument count and types from binaries? (ELF?)
	o)  Demangle C++ names.

Debugger:
	o)  see src/debugger.c for more

Userland ABI emulation:
	o)  see src/useremul.c

Terminal/console:
	o)  allow emulated serial ports to be connected to the outside
	    world in a more generic way, or even to other emulated
	    machines(?)

Save state of the whole emulated machine, to be able to load it back
	in later?  (Memory, all device's states, all registers and
	so on.  Like taking a snapshot. (SimOS seems to do this,
	according to its website.))

Better framebuffer and X-windows functionality:
	o)  -Yx sometimes causes crashes.
	o)  Simple device access to framebuffer_blockcopyfill() etc,
	    and text output (using the built-in fonts), for dev_fb.
	o)  CLEAN UP the ugly event code
	o)  Mouse clicks can be "missed" in the current system; this is
	    not good. They should be put on a stack of some kind.
	o)  More 2D and 3D framebuffer acceleration.
	o)  Non-resizable windows?  Or choose scaledown depending
		on size (and center the image, with a black border).
	o)  Different scaledown on different windows?
	o)  Switch scaledown during runtime? (Ala CTRL-ALT-plus/minus)
	o)  Keyboard and mouse events:
		x)  Do this for more machines than just DECstation
		x)  more X11 cursor keycodes
		x)  Keys like CTRL, ALT, SHIFT do not get through
		    by themselves (these are necessary for example
		    to change the font of an xterm in X in the
		    emulator)
	o)  Generalize the framebuffer stuff by moving _ALL_ X11
		specific code to src/x11.c!

Statistics:  (this could be interesting)
	o)  Save to file and show graphics. It should be possible to
	    run gxemul after a simulation to just show the graphics,
	    or convert to a .ppm or .tga or similar.
	o)  memory accesses (to measure cache efficiency and
		page coloring efficiency)
	o)  nr of simultaneous ASIDs in use in the TLB, for MIPS
	o)  percentage of time spent in different "states", such as
	    running userland code, kernel code, or idling (for CPUs
	    that have such an instruction, or whenever the PC is
	    inside a specific idle-function (address range)).
	    Possible additional state (for example on R3000): caches
	    disabled.
	o)  position of read/write on (SCSI) disks

