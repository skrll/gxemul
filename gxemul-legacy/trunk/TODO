$Id: TODO,v 1.582 2007-12-29 16:18:39 debug Exp $

Some things, in approximate Time order, that I'd like to implement or fix.
(Things at the top need to be fixed before those at the bottom.)

Some items in this list are perhaps already fixed. This is just a place
for me to do brain-storming.

Please note that GXemul 0.5.0 is a complete rewrite of GXemul, from scratch.
This file has nothing to do with the TODO files from previous versions
of GXemul.

-------------------------------------------------------------------------------

CommandInterpreter
	* Outputability!
	* Print Prompt when ready, i.e. after each command.
	* Implement the terminal stdin/out stuff!
	* Tab completion for everything:
		command names
		component names
		components' state variables
	* Built-in commands:
		quit
		help		Returns help message, as a string
		version		Returns the GXemul version (string)
		undo
		redo
		clearundo	Clears the undo/redo stack
		tree    Look at current configuration tree of components.
		focus   Set focus to somewhere in the tree (given a "path").
		add     Add a component somewhere in the tree.
		remove  Remove a component (including recursively
				removing all its children)
		save    Save configuration.
		load    Load configuration.
		close	Close current emulation.
		copy	copy a component (and its children) to the clipboard
		paste	paste a component from the clipboard
		reset   Reset configuration (i.e. reset all components).
		print expr  	Prints expression (gets a state variable).
		expr = value	Sets a state variable
	x)  "Object oriented" hierarchy, so that e.g.
		print machine0.mainbus0.pcibus0.dc0.register_this_and_that
	    would work.
	x)  Tab completion, for all commands, including the
	    object oriented extensions / variable names / etc.
	    INCLUDING tab completion inside sub components.
	    This might feel odd, but that would allow one to
	    type pci<TAB> to expand to machine.pci0  (if there
	    only is one pci bus), or if there are, say, three
	    machines with pci busses, that would give a
	    tab completion list, similar to this:
		machine0.pci0
		machine1.pci0
		machine1.pci1
		machine2.pci0
	x)  "Methods" on objects? E.g. ...vga.test
	x)  Strings should be supported, both for e.g. variable
	    assignment, and for e.g. placing strings in memory.
	x)  Arrays?


Components
----------

Actions for adding components to a GXemul instance, removing them...
Write UNIT TESTS for these actions.

New component source code tree, src/components/:
	busses/			mainbus, TurboChannel, ISA, PCI, ...
	cpus/
		CPU		class CPU : public Component, etc
		arm/
		alpha/
		mips/		etc. One for each CPU architecture
	graphics/		e.g. VGA graphics cards!
	displays/
		rgbmonitor	RGB monitor, for e.g. VGA output.
		lcd		LCD display
		led		A single led :)
	dummy/			Contains dummy test components, for testing
				the components framework (e.g. serialization...)
	machines/		Machines are usually TEMPLATES which set up a
				couple of other components!
	memory/			RAM, ROM, caches, ...
	network/		Ethernet and others end up here
	sound/			sound cards


Error handling, if loading a component tree fails! Think about this.


GTKMM GUI
---------

	x)  Dockable windows!

	x)  Command input window!  Make it look nice.

	x)  Copy/Paste of components! Both inside one GXemul instance,
	    and _BETWEEN APPLICATIONS_!

	x)  Menu bar:
		File
			New ->
				Emulation
				Emulation from template	  (e.g. "testmips")
				-----------------------
				GXemul instance
			Open
				(Open can show a list of "thumbnails"
				of the workspace plus e.g. one main
				window (such as a VGA display).)
			Close
			-----------
			Save
			Save as...
			-----------
			Quit
		Edit
			Copy
			Paste
		View
			[ ]  Show toolbar
			[ ]  Show workspace
			[ ]  Show debug console
			F11  Full screen mode (CTRL-ALT-F11 to get out of it)
		Emulation
			Start
			Pause/continue
			Reset
		Help
			Contents  (installed html files)
			About

	x)  Toolbar button area:
		Play (start emulation)
		Pause (pause emulation, button kept down until unpaused)
		Reset (with a dialog asking for confirmation)
		Undo/Redo!
	    (Optional plug-in-ability/extensibility. Buttons should
	    be bound to debugger commands.)

	x)  "Workspace", where emulations can be created
	    by drag-n-drop of components from a palette, and/or
	    from other emulations. Normally, the workspace window would
	    be docked in the "center" of the GXemul window, with the
	    command window below it.

	    The design mode should use cairo for drawing.

	    Dockable/undockable windows for machines/devices/
	    I/O-units' contents ?

	    Tooltips for components. (A "summary" of the entire
	    state window.)


Think about
-----------

	x)  Inspection of state of any Component...

	x)  Callstack window, etc. (per CPU).

	x)  Function call trace window (also per CPU).

	x)  ARBITRARY break conditions, i.e. between each instruction,
	    check any number of arbitrary conditions:
		x) Contents of memory locations, even including stuff
		   on the stack
		x) Any flags
		x) Any device state :)

	    This obviously slows things down A LOT, so the default is
	    to have no such break conditions.

	    TODO: Compile these conditions into some form of internal
	    byte code?

	x)  All debugger commands are functions, returning values?
	    read8(addr)   reads a byte from a memory object
	    version       returns a string, indicating the GXemul version
			  (note that "()" are optional, if the function
			  takes no arguments)
	    How about assignment of state variable values? TODO

	x)  Timing modes:
		1) Real-time approximation. (For guest OSes.)
		2) Fixed. (For fixed 1 instruction/cycle speed.)
		   Each device must then have a specified speed (such
		   as 50 MHz...)

	x)  Generic timer framework

	x)  Generic interrupt framework

	x)  Regular saving of state with time stamps (i.e. cycle numbers),
	    so that running "backwards" is possible!
	    NOTE:
		1) This must include network packages and disk image
		   contents! Tricky. But perhaps doable.
		2) Must be possible to use both from the UI (a "step
		   backwards" button?) and the debugger.

	x)  Actual machines being emulated 1 per process? Or all in the
	    same process?

	x)  Full-screen. CTRL-ALT-F11 toggles full-screen vs docked window
	    in the designer view? CTRL-ALT-F12 toggles mouse capture?

	x)  There can now be links directly into the documentation,
	    assuming it is installed. ($PREFIX/share/doc/gxemul/*.html)
	    I.e. F1 (and Help->Contents) can cause a web browser to be
	    launched.

	x)  Userland emulation! (Only from the command line.)

	x)  Command-line options compatible with pre-0.5.0! Start e.g.
	    framebuffers in full-screen / windowed mode, _not_ docked.

	x)  Hot-swap of devices during runtime, depends on Bus support. e.g.:
		PCMCIA
		USB
		Serial devices
		Parallel devices
		VGA monitors
		ADB
		Sun's old bus for keyboards/mice
		...

	x)  Architectures to concentrate on, from the beginning:
		MIPS (since that's what works best in GXemul < 0.5.)
			testmips, then pmax and others?
		M88K (so that the work so far isn't lost)
		amd64 (since there's more software to test that way, and
			it will be fun/interesting to devle into
			emulation of variable-length ISAs :-)
		some simple AVR microcontroller? for demos



Preparation for release 0.5.0:
------------------------------

 x) Not meaningful until enough functionality from the 0.4.x series have
    been duplicated.
    	o) testmips, testarm, etc?
    	o) most MIPS machines
    	o) basic debugger commands: trace tree, single step, registers, etc.

 x) No exact date is set for this. Perhaps during the later
    part of 2008? (If I am lucky enough to get lots of spare time.)

 x) Carefully read through all the source code.

 x) Build on as many platforms as possible, including running
    unit tests.

 x) Carefully check that the man page reflects the correct
    command line options etc.

 x) Carefully read through all the documentation, and test all
    instructions given there.

 x) Make sure that the web page looks reasonable. There should be
    clear ways to download the old 0.4.x version in addition to
    the 0.5.0 release.

