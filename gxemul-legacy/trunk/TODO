$Id: TODO,v 1.152 2005-08-04 10:53:23 debug Exp $

===============================================================================

High priority stuff:


MIPS bintrans:
	FIX THE CACHE/DEVICE BUG FOR 32-BIT EMULATION! This was caused by
	switching from a 2-level to a 1-level page table system for
	bintranslated code...
	i386: movn etc, slt[u] for 64-bit mode, 64-bit shifts etc

dyntrans:

	x)  memory write protection for ARM, but NOT for Alpha (because
		it has the IMB instruction... hm)

	x)  function call trace support?

	x)  instr_call sequence analysis support? (Useful for
		handtuning combinations.)

	x)  opcode statistics support?
		TODO: is instr_call statistics enough?

	x)  breakpoint support?

	x)  support for multiple word lengths (everything except alpha/arm)

	x)  support for variable-length instructions (x86, m68k, ...)
		Perhaps:  don't increase the next_ic between every
		instruction, but let each instruction's handler do
		that for itself.
		Problem: what about instructions crossing a (virtual)
			page boundary? They cannot be translated once
			and for all :( and must be interpreted slowly!

	x)  support for THUMB or MIPS16  (arm, mips)

	x)  support for Delay slots!  (mips, sparc, hppa)

	x)  Alpha: hahaha, zapnot and inserts/extracts don't
	    compile into very nice code :-|  fix this

	x)  PPC: convert instructions to dyntrans, allow for both 64-bit
	    and 32-bit operating modes!

	x)  x86: convert to dyntrans. LOTS of stuff to consider.


===============================================================================

Low priority stuff:

	Caches / memory hierarchies: (this is mostly MIPS-specific)
		o)  MIPS coproc.c: bits in config registers should reflect
		    correct cache sizes for _all_ CPU types. (currently only
		    implemented for R4000, R1x000, and a few others)
		o)  src/memory*.c: Implement correct cache emulation for
		    all CPU types. (currently only R2000/R3000 is implemented)
		    (per CPU, multiple levels should be possible,
		    associativity etc!)
		o)  R2000/R3000 isn't _100%_ correct, just almost correct :)
		o)  Move the -S (fill mem with random) functionality into the
		    memory.c subsystem, not machine.c or wherever it is now
		o)  ECC stuff, simulation of memory errors?  (Machine dependant)
		o)  More than 4GB of emulated RAM, when run on a 32-bit host?
		    (using manual swap-out of blocks to disk, ugly)
		o)  A global command line option should be used to turn
		    cache emulation on or off. When off, caches should be
		    faked like they are right now. When on, caches and
		    memory latencies should be emulated as correctly as
		    possible.

	Network layer:
		o)  Multiple networks per emulation, and let different
		    NICs in machines connect to different networks.
		o)  many other issues: see src/net.c

	CPU emulation:
		o)  Binary translation:
			+)  use an Intermediate Representation!
			+)  recursive translation?
			+)  basic blocks instead of one-instruction? :)
			+)  on Alpha: don't assume pca56-like byte load/store?
			+)  write backends for UltraSparc and MIPS
			+)  see src/bintrans.c for more info
		o)  Dynamic-but-not-binary translation?
		o)  All the non-MIPS modes need a bit of work.

	MIPS CPU emulation:
		o)  Instructions:
			o)  Regression tests (see tests/README for more info):
				o)  Floating point exception handling, and
					add more instructions.
				o)  Finish the MIPS16 translator, and test it!
				o)  MIPS ISA I, II, III, IV
				o)  MIPS V (SIMD vector stuff?)
				o)  MDMX  (MIPS Digital Media Extension)
				o)  MIPS 3D
				o)  MIPS MT (Multi-thread stuff) (What's this?)
			o)  Warn about mis-used bit fields (ie bits that
			    should be all zeroes, warn about if they are not)!
			    Both for coprocessor registers and for instruction
			    opcodes.
			o)  the special2 stuff is a mess right now
			o)  warn and/or cause exceptions for unimplemented
			    instructions (depending on CPU type)
		o)  R2000/R3000:
			x)  R3000 "tri-byte stores". (What's this?)
		o)  R4000 and others:
			x)  watchhi/watchlo exceptions, and other exception
			    handling details
		o)  R10000 and others:  (R12000, R14000 ?)
			x)  memory space, exceptions, ...
			x)  use cop0 framemask for tlb lookups
			    (http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/hdwr/bks/SGI_Developer/books/R10K_UM/sgi_html/t5.Ver.2.0.book_284.html)
		o)  Implement load delays?  Warnings on interlocks.
		o)  Implement all coprocessor 0 bits / functions.
			x)  coproc 0 selectors! (R4000 ?)
		o)  R4300 (nintendo64, no mmu?), R5900 (playstation2, weird
			TLB/cache? 128-bit GPRs, new instructions),
			4K (note: NOT R4000), 5K (note: NOT R5000),
			R6000 (ISA II), R8000
		o)  Multi-cpu stuff:
			+)  SGI's NUMA architecture. Study
				x)  Linux sources
				x)  SGI's specs on NUMA address space
			+)  Ultrix?  NetBSD doesn't do SMP on MIPS yet :-(
			+)  Own experiments with ycx2.

	Emulation of specific machines and devices:
		o)  Use same clock for all emulations and machines.
		o)  Clean up the device stuff (registering of devices etc)
		o)  Various SCSI and IDE controllers
		o)  PS/2-style keyboard controller (for several machines)
		o)  Generic busses;
			x)  PCI:  i/o and interrupts
			x)  QBus-22 (DECsystem 5500, 5400?)
		o)  DECstations (pmax):
			x)  ioasic
			x)  framebuffers:
				+)  better cursor support, overlays?,
				+)  2D/3D acceleration, PX[G]
			x)  status words / control words, make this more
				portable/cleaner
			x)  scsi controller(s): sii, DMA for asc
			x)  serial controllers: ssc, scc (and more work on dc?)
			x)  nvram on decstation 5000/125:  when using X11,
				set console=g or similar
			x)  DECstation 5840? "xbi-based SMP"
		o)  SGI and ARC machines (sgimips, arc):
			x)  IP32 ("O2"): (Lots of stuff)
				+)  mec (ethernet)
				+)  pci
				+)  ahc (scsi)
				+)  ps2 kbd
				+)  memory controller
				+)  framebuffer/graphics
				+)  caches
			x)  more ARCBIOS stuff
			x)  Memory/interrupt controllers
			x)  IP30 (Linux with graphics support?)
			x)  SMP / NUMA?  (SGI and various ARC machines)
		o)  Playstation 2:
			Hardware:  OHCI usb controller, keyboard, ...
		o)  Less interesting platforms (newsmips, mipsco, wgrisc, etc)

	File/disk handling:
		o)  Read function argument count and types from binaries? (ELF?)
		o)  Better handling of tape files

	Userland ABI emulation:
		o)  see src/useremul.c

	Terminal based interactive debugger:
		o)  see src/debugger.c

	Terminal/console stuff:
		o)  allow emulated serial ports to be connected to the outside
		    world in a more generic way, or even to other emulated
		    machines(!)

	Regression tests:  (Should be totally rewritten.)
		o)  see tests/

	Save state of the whole emulated machine, to be able to load it back
		in later?  (Memory, all device's states, all registers and
		so on.  Like taking a snapshot. (SimOS seems to do this,
		according to its website.))

	Better X-windows functionality:
		o)  CLEAN UP the ugly event code
		o)  Mouse clicks can be "missed" in the current system; this is
		    not good. They should be put on a stack of some kind.
		o)  More 2D and 3D framebuffer acceleration.
		o)  Non-resizable windows?  Or choose scaledown depending
			on size (and center the image, with a black border).
		o)  Different scaledown on different windows?
		o)  Switch scaledown during runtime? (Ala CTRL-ALT-plus/minus)
		o)  Keyboard and mouse events:
			x)  Do this for more machines than just DECstation
			x)  more X11 cursor keycodes
			x)  Keys like CTRL, ALT, SHIFT do not get through
			    by themselves (these are necessary for example
			    to change the font of an xterm in X in the
			    emulator)
		o)  Generalize the framebuffer stuff by moving _ALL_ X11
			specific code to src/x11.c!

	Statistics:  (this could be interesting)
		o)  Save to file and show graphics. It should be possible to
		    run gxemul after a simulation to just show the graphics,
		    or convert to a .ppm or .tga or similar.
		o)  memory accesses (to measure cache efficiency and
			page coloring efficiency)
		o)  nr of simultaneous ASIDs in use in the TLB, for MIPS
		o)  percentage of time spent in different "states", such as
		    running userland code, kernel code, or idling (for CPUs
		    that have such an instruction, or whenever the PC is
		    inside a specific idle-function (address range)).
		    Possible additional state (for example on R3000): caches
		    disabled.
		o)  position of read/write on (SCSI) disks

