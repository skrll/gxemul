$Id: TODO,v 1.256 2006-05-01 07:55:38 debug Exp $

Hm. This file is in random order, and not all parts of it are up-to-date.

--------------

Stuff to finish before a 0.4.0 release:

	x)  MIPS dyntrans working at least as well as the old mode did.
		+)  R2000/R3000 caches
		+)  Remaining other bug (Ultrix weirdness etc).
		+)  No release until everything mentioned in the
		    documentation is working as in 0.3.8.
		+)  Remove obvious bottlenecks, and do at least _some_
		    optimization before the release.
	x)  Complete removal of bintrans! :-)

--------------

MIPS:
	o)  Dyntrans: R2000/R3000 caches don't quite work yet (NetBSD/pmax,
	    Ultrix, Sprite, etc).
	o)  Dyntrans: Count register updates are probably not 100% correct yet.
	o)  Dyntrans: SMP correctness
	o)  Refactor code for performance and readability/maintainability.
	o)  R4000 and others:
		x)  watchhi/watchlo exceptions, and other exception
		    handling details
	o)  R10000 and others:  (R12000, R14000 ?)
		x)  memory space, exceptions, ...
		x)  use cop0 framemask for tlb lookups
		    (http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/hdwr/bks/SGI_Developer/books/R10K_UM/sgi_html/t5.Ver.2.0.book_284.html)

Dyntrans:
	x)  Common "invalid()" function with friendly fatal error message?
	x)  INVALIDATION should cause translations in _all_ cpus to be
	    invalidated, e.g. on a write to a write-protected page
	    (containing code)
	x)  better (formally defined) instr call statistics (-s command
	    line option?), multiple different types? (virtual pc, physical pc)
	x)  Call/return hints?
	x)  16-bit encodings? (MIPS16, ARM Thumb, SH3, ...)
	x)  H8?
	x)  Lots of other stuff: see src/cpus/README_DYNTRANS
	x)  true recompilation backend? think carefully about this,
	    experiment in a separate project (not in GXemul)
	x)  Remove the dyntrans_alignment_check functionality; although
	    it gives slightly higher peformance sometimes, it increases
	    the complexity of the code too much!

Alpha:
	o)  Virtual memory (tlbs etc)
	o)  Get {NetBSD,OpenBSD,Linux}/alpha booting. :)

SPARC:
	o)  Add all registers (floating point, control regs etc)
	o)  Add old-style (32-bit) SPARC processors too!
	o)  Save/restore register windows etc!
	o)  Disassemly of some more instructions.
	o)  Are sll etc 32-bit sign-extending or zero-extending?
	o)  Finish the GDB register stuff.

Debugger:
	o)  MIPS gdb stub "p" command vs "g" command!
	o)  How does SMP debugging work? Does it simply use "threads"?
	o)  Try to make the debugger more modular and, if possible, reentrant!
	o)  Remove the emul command? (But show network info if showing
		machines?)
	o)  Generalize the expression evaluator. (debugger_expr.c?)
	o)  Place commands in a separate file, the "main engine" in a
	    separate file, etc.  (debugger_cmds.c)
	o)  see src/debugger.c for more

The configure script:
	x)  Remove the Cache option, since it is broken anyway.
	x)  Remove the delay option, since it isn't really used. Turn
	    into a runtime command line option? Or enable this together
	    with cache simulation?

POWER/PowerPC:
	x)  PPC optimizations; instr combs
	x)  64-bit stuff
	x)  find and fix the bug which causes NetBSD/macppc to fail after
	    an install!
	x)  macppc: adb controller; keyboard (for framebuffer mode)
	x)  make OpenBSD/macppc work (PCI controller stuff)

Algor:
	PCI and ISA and LOCAL interrupts! --> wdc could start working
	Add interrupt controller in dev_algor.c.

ARM:
	o)  try to get netbsd/evbarm 3.x running (iq80321)
	o)  make the xscale counter registers (ccnt) work
	o)  make the ata controller usable for FreeBSD!
	o)  zaurus for openbsd...
	o)  debian/cats crashes because of unimplemented coproc stuff.
	    fix this?

Cache simulation:
	o)  Separate from the CPU concept, so that multi-core CPUs sharing
	    e.g. a L2 cache can be simulated (?)
	o)  Instruction cache emulation is easiest (if separate from the
	    data cache); similar hack as the S;I; hack in cpu_dyntrans.c.
	    NOTE: if the architecture has a delay slot, then an instruction
	    slot can actually be executed as 2 instructions.
	o)  Data cache emulation = harder; each arch's load/store routines
	    must include support? running one instruction at a time and
	    having a cpu-dependant lookup function for each instruction
	    is another option (but very very slow).

Documentation:
	o)  machines, cpus, devices.
	o)  Automagic documentation generation:
		x)  REMEMBER that several machines/devices can be in
			the same source file!
	o)  Try to rewrite the install instructions for those machines
	    that use 3MAX into using CATS? (To remove the need to a raw
	    ffs partition using up all of the disk image.)

More generic out_of_memory error reporting, and check everywhere!
	Causes:	OpenBSD has low default limits for normal users.
		Host is 32-bit? (32-bit hosts are limited to 4 GB or less
		of userspace memory.)
		You are actually low on RAM. (As trivial as this might sound,
		Unix systems usually allow processes to allocate virtual
		memory beyond the amount of RAM in the machine.)

Breakpoints: 32-bit vs 64-bit sign extension for MIPS, warnings, etc.
	Use the debugger's symbolic name stuff. (which will have to be
	extended soon to support stuff like  "2*x + symbol + y" etc. cool
	stuff)

Sprite (guest OS for DECstation emulation)
	x)  Timing problems during bootup?

The Device subsystem:
	x)  allow devices to be moved and/or changed in size (down to a
	    minimum size, etc, or up to a max size)
	x)  keep track of interrupts and busses? actually, allowing any device
	    to be a bus might be a nice idea.
	x)  turn interrupt controllers into devices? :-)
	x)  refactor various clocks/nvram/cmos into one device?

Clocks:
	x)  General framework for automagic clock adjustment for _all_
	    kinds of clocks and timers. (Which should be possible to turn
	    off, of course, like the way DECstation emulation works now.)

PCI:
	x)  last write was ffffffff ==> fix this, it should be used
	    together with a mask to get the correct bits. also, not ALL
	    bits are size bits! (lowest 4 vs lowest 2?)
	x)  add support for address fixups
	x)  generalize the interrupt routing stuff (lines etc). this should
	    be per machine? or per bus, that's better

Network layer:
	o)  DHCP (for Debian and BSD installers :-)
	o)  increase performance
	o)  don't rely on NetBSD-ish usage
	o)  Multiple networks per emulation, and let different
	    NICs in machines connect to different networks.
	o)  many other issues: see src/net.c

Busses:
	o)  Redesign the entire "mainbus" concept!
	o)  Busses should be placed in a hierarchical tree!
	o)  Easily configurable interrupt routing in SMP systems.
	o)  Specific clock/bus speeds, cpu speeds etc.
	o)  Synchronization over network? or at least in dyntrans within
	    one emulated machine
	o)  dev->bus: TurboChannel, PCMCIA, ADB?

Config file parser:
	o)  Rewrite it from scratch!
	o)  Usage of any expression available through the debugger
	o)  Support for running debugger commands (like the -c
	    command line option)

Floating point layer:
	o)  make it common enough to be used by _all_ emulation modes
	o)  implement more stuff
	o)  non-IEEE modes (i.e. x86)?

Userland emulation:
	x)  Lots of stuff; freebsd and netbsd (and linux?) syscalls.
	x)  Dynamic linking? Hm.

Sound:
	x)  generic sound framework
	x)  add one or more sound cards as devices

ASC SCSI controller:
	x)  NetBSD/arc 2.0 uses the ASC controller in a way which GXemul
	    cannot yet handle. (NetBSD 1.6.2 works ok.) (Possibly a problem
	    in NetBSD itself, http://mail-index.netbsd.org/source-changes/
	    2005/11/06/0024.html suggests that.)

Caches / memory hierarchies: (this is mostly MIPS-specific)
	o)  MIPS coproc.c: bits in config registers should reflect
	    correct cache sizes for _all_ CPU types. (currently only
	    implemented for R4000, R1x000, and a few others)
	o)  src/memory*.c: Implement correct cache emulation for
	    all CPU types. (currently only R2000/R3000 is implemented)
	    (per CPU, multiple levels should be possible,
	    associativity etc!)
	o)  R2000/R3000 isn't _100%_ correct, just almost correct :)
	o)  Move the -S (fill mem with random) functionality into the
	    memory.c subsystem, not machine.c or wherever it is now
	o)  ECC stuff, simulation of memory errors?  (Machine dependent)
	o)  More than 4GB of emulated RAM, when run on a 32-bit host?
	    (using manual swap-out of blocks to disk, ugly)
	o)  A global command line option should be used to turn
	    cache emulation on or off. When off, caches should be
	    faked like they are right now. When on, caches and
	    memory latencies should be emulated as correctly as
	    possible.

File/disk/symbol handling:
	o)  Better handling of tape files
	o)  Read function argument count and types from binaries? (ELF?)
	o)  Better demangling of C++ names. Note: GNU's C++ differs from e.g.
	    Microsoft's C++, so multiple schemes must be possible. See
	    URL at top of src/symbol_demangle.c for more info.

Userland ABI emulation:
	o)  see src/useremul.c

Terminal/console:
	o)  allow emulated serial ports to be connected to the outside
	    world in a more generic way, or even to other emulated
	    machines(?)

Save state of the whole emulated machine, to be able to load it back
	in later?  (Memory, all device's states, all registers and
	so on.  Like taking a snapshot. (SimOS seems to do this,
	according to its website.))

Better framebuffer and X-windows functionality:
	o)  -Yx sometimes causes crashes.
	o)  Simple device access to framebuffer_blockcopyfill() etc,
	    and text output (using the built-in fonts), for dev_fb.
	o)  CLEAN UP the ugly event code
	o)  Mouse clicks can be "missed" in the current system; this is
	    not good. They should be put on a stack of some kind.
	o)  More 2D and 3D framebuffer acceleration.
	o)  Non-resizable windows?  Or choose scaledown depending
		on size (and center the image, with a black border).
	o)  Different scaledown on different windows?
	o)  Switch scaledown during runtime? (Ala CTRL-ALT-plus/minus)
	o)  Keyboard and mouse events:
		x)  Do this for more machines than just DECstation
		x)  more X11 cursor keycodes
		x)  Keys like CTRL, ALT, SHIFT do not get through
		    by themselves (these are necessary for example
		    to change the font of an xterm in X in the
		    emulator)
	o)  Generalize the framebuffer stuff by moving _ALL_ X11
		specific code to src/x11.c!

Statistics:  (this could be interesting)
	o)  Save to file and show graphics. It should be possible to
	    run gxemul after a simulation to just show the graphics,
	    or convert to a .ppm or .tga or similar.
	o)  memory accesses (to measure cache efficiency and
		page coloring efficiency)
	o)  nr of simultaneous ASIDs in use in the TLB, for MIPS
	o)  percentage of time spent in different "states", such as
	    running userland code, kernel code, or idling (for CPUs
	    that have such an instruction, or whenever the PC is
	    inside a specific idle-function (address range)).
	    Possible additional state (for example on R3000): caches
	    disabled.
	o)  position of read/write on (SCSI) disks

