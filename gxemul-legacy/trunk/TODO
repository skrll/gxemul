mips64emul TODO
---------------

Most important stuff (but these are all non-trivial tasks):

  o)  DECstations:
	x)  write 'sii' or 'asc' SCSI interface stuff for pmax so that harddisk images can be used
	x)  Make interrupt sharing more generic!
	x)  try to install NetBSD/pmax onto a fake SCSI-disk
	x)  try to compile mips64emul _inside_ a running NetBSD/pmax system
	x)  try to run X inside NetBSD, using framebuffer(s) with mouse support!

  o)  Binary tree for memory mapped devices!
  o)  Separate RAM as yet another device (a "RAM device"), replacing the
      'memory' system with a more generic 'memory controller'.

  o)  Speed optimizations:
	x)  memory_rw() cache for recently used pages. (how to invalidate
	    pages? write-through? invalidate on tlb updates?)
	    (perhaps place this cache in the src/cpu.c module, so that it can
	    be inlined or optimized together with that module)

-------------------------------------------------------------------------------------

	CPU Emulation:
		o)  Instructions:
			x)  Add exception support to all instructions!
			x)  Go through the ENTIRE MIPS64 ISA and VR5432 ISA and make sure that
			    every instruction is:
				*  included in the emulator,
				*  tested using a kind of regression test (ie test code
				   written in mips assembly language)
			x)  Floating point instructions. (ISA I and II?)
			x)  MIPS16:
				x)  implement all instructions
			x)  MIPS V (SIMD vector stuff?)
			x)  MDMX?  (MIPS Digital Media Extension)
			x)  Warn about mis-used bit fields (ie bits that should be
				all zeroes, warn about if they are not)!
				Both for coprocessor registers and for instruction opcodes.
			x)  warn and/or cause exceptions for unimplemented instructions,
				at specific ISA levels.
			x)  Something radical:  instead of a large switch/case thing,
				I could implement some kind of tree-structure of masks
				and comparisions, and arrays of functions to call. Hm.
				(Performance hack.)
		o)  coproc 0 selectors!
		o)  Nr of instructions per second is NOT the number of cycles
		    per second, this is CPU dependant.  Several subsystems (CPUs,
		    other systems) may need to have speeds fixed relative to each
		    other.
		o)  R4000:  watchhi/watchlo exceptions, and other exception
		    handling details
		o)  r2k/r3k: Make sure that registers (INCLUDING coprocessor registers)
		    are always sign-extended. (32-bit stuff)
		o)  R3000 "tri-byte stores"???
		o)  Delay after R3000 interrupt enabling instructions (write to cop0),
		    before interrupts are actually enabled. (?)
		o)  Implement load delays?  Warnings on interlocks.
		o)  Implement all coprocessor 0 bits / functions.
			x)  BEV and all exception vectors....
			x)  Actual 64-bit addressing
		o)  R5900:  weird TLB/cache? 128-bit GPRs? new instructions?
		o)  5K, r10000: I've printed the manuals, so these should
			be possible to cover
		o)  actually use the R10K framemask for tlb lookups
			http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/hdwr/bks/SGI_Developer/books/R10K_UM/sgi_html/t5.Ver.2.0.book_284.html
		o)  R12000, R14000, R6000 (MIPS ISA II?), R8000 ?, R20000 ?

	Emulation of specific machines and devices:
		o)  Binary tree for memory mapped devices!
		o)  Separate RAM as yet another device (a "RAM device"), replacing the
			'memory' system with a more generic 'memory controller'.

		o)  Busses, interrupt systems, and ROM emulation:
			x)  Make interrupt sharing more generic!
			x)  TURBOchannel  (many DEC systems)
			x)  QBus (DECsystem 5400)
			x)  ARCBIOS (SGI, arc?)
			x)  PCI  (Cobalt, SGI, ...)

		o)  DECstations (pmax):
			framebuffers:
				x) programmable cursors?
				x) overlays?
				x) 2D/3D accelerated framebuffers?
				x) more VDACs
			status words / control words, make this more portable/cleaner
			scsi controller(s): sii, asc
			ethernet controller(s): le, fddi?
			serial controllers: dc, ssc, scc
			download the ROM from my DECstation 5000/125 and
				see if I can get it to run. (add an option to
				the emulator to be "bare", ie no ROM emulation
				in software)
			DECstation 5840? "xbi-based SMP"

		o)  Cobalt:
			PCI:  Tulip ethernet and harddisk controller

		o)  SGI and ARC machines (sgimips, arc):
			x)  More ARCBIOS stuff must be implemented
			x)  PCI (ARC and SGI)
			x)  Jazz (ARC)
			x)  SMP?
			x)  Interrupts (both ARC and SGI)
			x)  ARC: NEC-RD94 = NEC RISCstation 2250. Has a TGA framebuffer.

		o)  hpcmips:
			framebuffer(s)
			harddisk controller

		o)  Playstation 2:
			R5900 "weird" instructions
			Hardware (graphics, sound, dma, ...)
			Has an R3000A as a subsystem (!)
			ftp://ftp.NetBSD.org/pub/NetBSD/arch/playstation2/snapshot/20020327/

		o)  Playstation 1? R3000A. Weird hardware?
			No FPU, but something as coproc 2.
			(Perhaps the PS1 is a subset of the PS2.)

		o)  Nintendo 64, http://www.nintendo.com/systems/n64/n64_specs.jsp
			(R4300 or R4000? 4MB RAM?)

		o)  newsmips?

	Framebuffer stuff:
		o)  "Sprites", or overlays  (useful for cursors...)
		o)  2D and 3D acceleration
		o)  Playstation 2 color encoding is not rgb
		o)  Move the polygon drawing stuff to its own module.
		o)  Antialiased polygons? :-)

	Code cleanup:
		o)  Namespace consistency
		o)  Struct encapsulation:  no global variables, or at least
			as few as possible
		o)  No hardcoded values, use #defines

	Multi-cpu stuff:
		either do it in a way which emulates a real MP MIPS machine,
		or I'll just implement my own way, with some structures
		in memory telling the operating system running what
		cpus there are available, and how to access them)
		Perhaps Ultrix supports SMP?  Or Irix?  Otherwise, try with
		ycx2.

	Caches / memory hierarchies:
		o)  Implement correct cache emulation (per CPU, multiple
		    levels should be possible)
		o)  Increase performance of the emulator by caching data on the
		    host (separately, but in cooperation with the emulated CPUs'
		    caches).  A small number (say ~ 32) of small cache blocks
		    (a few KBs at most) might do it.
		o)  Move the -H (fill mem with random) functionality into the
			memory.c subsystem, not machine.c or wherever it is now
		o)  ECC stuff, simulation of memory errors?
		o)  More than 4GB of emulated RAM, when run on a 32-bit host?
			(using manual swap-out of blocks to disk)

	File handling:
		o)  Read function argument types from binaries? (ELF?)
		o)  zlib support (should be optional) for:
			x)  loading gzipped kernels directly
			x)  (read-only) disk images (?)
		o)  ELF: separate LE/BE (MIPS instruction format) from LSB/MSB
			(ELF structure format)

	Better X-windows functionality:
		o)  Keyboard and mouse events should be handled, translated
			into whatever the current emulated machine wants,
			for example turning those events into data sent into
			the machine on a serial port...
		o)  Non-resizable windows
		o)  Fix color support for non-24-bit modes
		o)  Generalize the framebuffer stuff by moving _ALL_ X11 specific
			code to src/x11.c!

	Profile the whole emulator, and try to increase performance. As
		of now it is utterly slow.

	Interactive/graphical single step debugger?

	Statistics:  (this could be interesting)
		o)  memory accesses (to measure cache efficiency and
			page coloring efficiency)
		o)  nr-of-instructions-in-a-row-that-don't-affect-eachother,
			and make histograms of this data

	Make sure that the emulator compiles and runs on as many Unices as
	possible, with different compilers and compiler settings. (Maybe on
	non-Unix-like systems too, if the X11 stuff is separated well enough.)

	Write Documentation (TeX/HTML/manpages) for the whole emulator.

