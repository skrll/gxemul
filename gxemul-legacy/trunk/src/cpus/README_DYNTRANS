$Id: README_DYNTRANS,v 1.9 2006-03-15 20:34:05 debug Exp $

-------------------------------------------------------------------

PPC optimizations TODO:

	find high-level bottlenecks!

	inline cr0 field calculation

	load/store with r1 as base?

	multiple load/stores in a row (especially with base = r1)

	almost all branches are of the "general" form now, they don't
		need to be.

	combinations of compare + branch, similar to arm?

-------------------------------------------------------------------



Dyntrans TODO:

  x)  Make sure that all of these could work, at least in theory:

			Instruction			Word		Delay
	Arch.:		length:				size:		slot:
	------		-------				-----		-----
	Alpha		32-bit				64		no
	ARM		32-bit, 16-bit (Thumb)		32		no
	Atmel AVR	16-bit + variable		8		no
	F-CPU		?				?		?
	H8		16-bit				8/16		no
	HPPA		32-bit				64/32		yes
	i960		32-bit + variable		32		?
	IA64		128-bit				64		no
	M68K		16-bit + variable		32		no
	M88K		?				32 (?)		?
	MIPS		32-bit, 16-bit (MIPS16)		64/32		yes
	OpenRISC	?				?		?
	PC532		?				32 (?)		?
	POWER/PPC	32-bit				64/32		no
	SH		32-bit, 16-bit (SHcompact)	64/32		yes(*)
	SPARC		32-bit				64/32		yes
	x86		8-bit + variable		64/32/16	no
	VAX		8-bit + variable		32		no

	(*) Delay slot in SHcompact?


  x)  call/return address cache?

  x)  instr_call sequence analysis support? (For handtuning combinations.)

  x)  opcode statistics support?
		TODO: is instr_call statistics enough?

  x)  load/stores:
		o)  perhaps refactor/reuse common load/store code?
		o)  support for archs that allow transparent
		    unaligned load/stores (ppc, x86 etc)
		o)  alignment checks ==> exceptions
		o)  native byte order ==> faster loads, etc.

  x)  actual cache emulation

  x)  SMP: detect when an instruction such as ll/sc or cas is used,
	    and "synchronize" approximately the number of executed instructions
	    (or cycles) across all CPUs.

  x)  support for variable-length instructions (x86, m68k, i960, ...)
		Solution:  don't increase the next_ic between every
			instruction, but let each instruction's handler do
			that for itself.
		Problem: what about instructions crossing a (virtual)
			page boundary? They cannot be translated once
			and for all :( and must be interpreted slowly!

  x)  support for THUMB, MIPS16, userland SH  (arm, mips, sh)

  x)  support for Delay slots!  (mips, sparc, hppa, SHcompact?)

  x)  various register-window archs (SPARC etc)

  x)  Alpha: hahaha, zapnot and inserts/extracts don't
	    compile into very nice code :-|  fix this
		Solution: if short assembly language snippets can be
		compiled on the current host, then compile such snippets
		for alpha_instr_zapnot etc.

  x)  x86: convert to dyntrans. LOTS of stuff to consider.

  x)  88k? vax? pc532? 6502? 6800? etc

