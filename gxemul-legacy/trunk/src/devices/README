$Id: README,v 1.2 2004-07-02 18:20:42 debug Exp $
(This should be in sync with doc/technical.html)


README for mips64emul devices
-----------------------------

Basically, each file in this directory is responsible for one hardware 
device. These are used from src/machine.c, when initializing which 
hardware a particular machine model will be using.

(I'll be using the name 'foo' as the name of the device in all these
examples.  This is pseudo code, it might need some modification to 
actually compile and run.)

Each device should have the following:


    o)	An init function in dev_foo.c. It would typically look something
	like this:

		void dev_foo_init(struct cpu *cpu, struct memory *mem,
		    uint64_t baseaddr, int irq_nr)
		{
			struct foo_data *d;

			d = malloc(sizeof(struct foo_data));
			if (d == NULL) {
				fprintf(stderr, "out of memory\n");
				exit(1);
			}
			memset(d, 0, sizeof(struct foo_data));
			d->irq_nr = irq_nr;

			memory_device_register(mem, "foo", baseaddr,
			    DEV_FOO_LENGTH, dev_foo_access, d);

			/*  This should only be here if the device
			    has a tick function:  */
			cpu_add_tickfunction(cpu, dev_foo_tick, d,
			    FOO_TICKSHIFT);
		}


    o)  The init function, the access function (described further down)
	and DEV_FOO_LENGTH should be defined in include/devices.h.


    o)  At the top of dev_foo.c, the foo_data struct should be defined.

		struct foo_data {
			int	irq_nr;
			/*  ...  */
		}


    o)  If foo has a tick function (that is, something that needs to be
	run at regular intervals) then FOO_TICKSHIFT and a tick function
	need to be defined as well:

		#define FOO_TICKSHIFT		10

		void dev_foo_tick(struct cpu *cpu, void *extra)
		{
			struct foo_data *d = (struct foo_data *) extra;

			if (.....)
				cpu_interrupt(cpu, d->irq_nr);
			else
				cpu_interrupt_ack(cpu, d->irq_nr);
		}


    o)	And last but not least, the device should have an access function.
	The access function is called whenever there is a load or store
	to an address which is in the device' memory mapped region.


		int dev_foo_access(struct cpu *cpu, struct memory *mem,
		    uint64_t relative_addr, unsigned char *data, size_t len,
		    int writeflag, void *extra)
		{
			struct foo_data *d = extra;
			uint64_t idata = 0, odata = 0;

			idata = memory_readmax64(cpu, data, len);
			switch (relative_addr) {
			/* .... */
			}

			if (writeflag == MEM_READ)
				memory_writemax64(cpu, data, len, odata);

			/*  Perhaps interrupts need to be asserted or
			    deasserted:  */
			dev_foo_tick(cpu, extra);

			/*  Return successfully.  */
			return 1;
		}


The return value of the access function has until 20040702 been a 
true/false value; 1 for success, or 0 for device access failure. A device 
access failure will be seen as a MIPS DBE exception from the CPU.

Right now I'm converting the devices to support arbitrary memory latency 
values. The return value is now the number of cycles that the read or 
write access took. A value of 1 means one cycle, a value of 10 means 10 
cycles. Negative values are used for device access failures, and the 
absolute value of the value is then the number of cycles; a value of -5 
means that the access failed, and took 5 cycles.

To be compatible with pre-20040702 devices, a return value of 0 is treated 
by the caller (in src/memory.c) as a value of -1.

