<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>GXemul: TODO list</title>
  <meta name="robots" content="noarchive,nofollow,noindex">
</head>
<body style="font-family : sans-serif;">

<!-- 10 lines header.  -->

<h1>TODO list for GXemul</h1>
<p>

<a href="./">Back to the index.</a>


<p><br>
Here are some things, in no specific order, that I'd like to fix or
implement in GXemul. Some items in this list are perhaps already fixed.


<p><pre>
<b>Current "short-list":</b>

o) verbosity settings for debug messages for individual subsystems:
	debugmsg_init() -- registers subsystems.
		SUBSYS_STARTUP = ""
		SUBSYS_NET = "net"
		SUBSYS_DEVICE = "device"
		SUBSYS_CPU = "cpu"
		SUBSYS_EXCEPTION = "exception"
	int subsys_number = debugmsg_register_subsystem(const char* name);
		int *debugmsg_current_verbosity;
		const char *debugmsg_subsystem_name;
		static int debugmsg_nr_of_subsystems;
	debugmsg(int subsys, int verbosity_required, "%s", ...)
	if (debugmsg_current_verbosity[subsys] >= verbosity_required) ...

	"[ " + " ]" only when executing, i.e. not during startup or when
	paused in the debugger.
	
	subsysname only if not "" (SUBSYS_STARTUP).
	"name: " only if name is not "" or NULL.

	[ subsysname name: string ]

	if using color, then subtly color subsysname in one color, and name
	in a second color.
	
	VERBOSITY_ERROR = 0
	VERBOSITY_WARNING = 1
	VERBOSITY_INFO = 2
	VERBOSITY_DEBUG = 3
	...

	Use red/bold for ERROR for the string?

o) C++ to C switch:
	x. Reimplement the i960 CPU. (Disassembly of i960CA instructions.)
	x. Reimplement the HP700/RX machine.

o) Mouse capture for X11 windows?

o) Disk overlay short-hand for temporary images. -R?
o) Continue on Luna 88k machine:
	SMP stability?
	color framebuffer?
	SCSI?
	Cursor keys in the graphical framebuffer window? (Works with pckbd for SGI?)
	separate out some devices into their own files? (reuse TOD clock for example)
	Front-side LED?
o) Go through "exit()" calls and replace by reasonable break-into-the-debugger
   constructs. Make sure that -K, -T etc are adhered to.
o) Breakpoints with config files doesn't seem to work correctly? (luna88k?)
o) Go through the ,NULL arguments to dev_ram_init, and see if more suitable names can be used!
o) Try using profil() for very basic runtime profiling?
o) MIPS: ehb detection, cop0 write -> tlb instructions.
o) CTRL-T in main window could print SIGINFO-like status summary
o) Continue on SGI O2: PCI (moving devices in memory at runtime?), SCSI (?), ...
o) Continue on i960 stuff, in particular HP 700/RX stuff. :-)
o) Double-check R10000 vs R4400 TLB specifics:
   https://techpubs.jurassic.nl/manuals/hdwr/developer/R10K_UM/sgi_html/t5.Ver.2.0.book_347.html
o) If/when booting from SGI disk images is really meaningful (i.e. not just that it
   correctly loads the OSLoader, but can boot an entire OS): update the man page
   and other documentation regarding booting directly from SGI disk images.
o) Building GXemul 0.6.2 inside emulated NetBSD/hpcmips 8.1 says:
	# date > a; ./configure && make; date > b; cat a; cat b
	checking which C++ compiler to use... c++ -DNDEBUG 
	checking for X11 headers and libs
	Using NetBSD hack for X11 libs...
	Failed to compile X11 test program. Configuring without X11.
   Investigate this!
o) Update test device section on "fb": set and read resolution
o) testmips: Add support for more than 256 MB ram, e.g. by adding
	"actual RAM" at the 1 GB offset. A 32 bit machine can thus use
	3 GB, no limit on 64 bit machines. Low 256 MB can be considered
	a mirror of first 256 MB of RAM.
o) Malta: see if 2 GB ram can be used there as well (like the SGI O2 mode).
o) Command line option for forcing fsync on each disk image write.
o) O(n) -> O(1) 64-bit translation invalidation, _IF_ it is possible to
	detect non-canonical virtal addresses being entered into the
	translation arrays. Would be nice.
o) GXsatellite -- Gavare's eXperimental Stand-Alone Test Environment
   for Low-Level Interactive Testing of Emulators. base on YCX5; start with testmips.





Debugger:
	Extend the
		put [b|h|w|d|q] addr, data    modify emulated memory contents
	command with a "s" (string) mode, where data is a string. Also
	"z" which puts a nul-terminated string in memory. It should put the
	string there one byte at a time.
	
		put s 0x80008000, "apa"

	or

		put z 0x80008000, "apa"


	Extend the debugger with a "find" command as well, similar to
	put but with a range?

		find [b|h|w|d|q|s|z] startaddr, endaddr, data

Floating point:
	More tests.
	
Documentation:
	Add the Android ARM machine modes to the documentation, machine_androidarm, color red,
	once the Linux device tree has been at least implemented enough to see some
	boot messages or so.

	Add the Alpha mode too even though probably almost nothing works at all.
	Also red. Try to include instructions for NetBSD, OpenBSD
	and FreeBSD although the later has been discontinued.

	Add FreeBSD/mips to testmips section? https://wiki.freebsd.org/FreeBSD/MipsEmulation
	If it works.

Disk image options:
	'R' (uppercase): don't allow writes to the disk image file, but let
	the guest OS think that the device is writable, by using a temporary
	overlay (created automatically in /tmp) which is removed when the
	emulator exits. If this is implemented, update the misc
	documentation, and the man page.

X11:
	-y n: Command line option for taking framebuffer screen shots n times
	per second? Look for "ppm image dumps" in dev_fb.cc.html. if 
	implemented, add to man page.

Wayland:
	-W ?

MIPS:
	o)  ALU operations (typically addiu, or, etc) can be hardcoded/inlined for common
		register pairs or even triples. Classic generate_blahblah and an array.
		Reduces memory accesses for common ALU instructions.
	o)  Profile and make newer instruction combinations for up-to-date versions of NetBSD
	    (full install, building GXemul inside NetBSD, etc). Make sure to go through all
		common function cores such as memset, memcpy, memmove, strlen, strcmp, memcmp,
		and idle functions, for both R3000 and R4400 etc.
	o)  Floating point exception correctness. Compare to real hardware!
	o)  Nicer MIPS status bits in register dumps.
	o)  Some more work on opcodes.
		x) MIPS64 revision 2.
			o)  Find out which actual CPUs implement the rev2 ISA!
			o)  DINS, DINSM, DINSU etc
			o)  DROTR32 and similar MIPS64 rev 2 instructions,
			    which have a rotation bit which differs from
			    previous ISAs.
	o)  NetBSD has a patch for NOFPU flag for certain CPUs. Investigate and apply if correct.
	o)  Dyntrans: Count register updates are probably not 100% correct yet.
	o)  Coprocessor 1x (i.e. 3) should cause cp1 exceptions, not 3?
		(See http://lists.gnu.org/archive/html/qemu-devel/2007-05/msg00005.html)
	o)  R4000 and others:
		x)  watchhi/watchlo exceptions, and other exception
		    handling details
	o)  MIPS 5K* have 42 physical address bits, not 40/44?
	o)  R10000 and others:  (R12000, R14000 ?)
		x)  The code before the line
			/*  reg[COP0_PAGEMASK] = cpu->cd.mips.coproc[0]->tlbs[0].mask & PAGEMASK_MASK;  */
		    in cpu_mips.c is not correct for R10000 according to
		    Lemote's Godson patches for GXemul. TODO: Go through all
		    register definitions according to http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/hdwr/bks/SGI_Developer/books/R10K_UM/sgi_html/t5.Ver.2.0.book_263.html#HEADING334
		    and make sure everything works with R10000.
		    Then test with OpenBSD/sgi?
		x)  Entry LO mask (as above).
		x)  memory space, exceptions, ...
		x)  use cop0 framemask for tlb lookups [maybe already working correctly?]
		    (http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/hdwr/bks/SGI_Developer/books/R10K_UM/sgi_html/t5.Ver.2.0.book_284.html)

SuperH:
	x)  Auto-generation of loads/stores! This should get rid of at least
	    the endianness check in each load/store.
	x)  Experiment with whether or not correct ITLB emulation is
	    actually needed. (20070522: I'm turning it off today.)
	x)  SH4 interrupt controller:
		x)  MASKING should be possible!
	x)  SH4 UBC (0xff200000)
	x)  SH4 DMA (0xffa00000): non-dreamcast-PVR modes
	x)  Store queues can copy 32 bytes at a time, there's no need to
	    copy individual 32-bit words. (Performance improvement.)
	    (Except that e.g. the Dreamcast TA currently receives using
	    32-bit words... hm)
	x)  SH4 BSC (Bus State Controller)
	x)  Instruction tracing should include symbols for branch targets,
	    and so on, to make the output more human readable.
	x)  SH3-specific devices: Pretty much everything!
	x)  NetBSD/evbsh3, hpcsh! Linux?
	x)  Floating point speed!
	x)  Floating point exception correctness.
		E.g. fipr and the other "geometric" instructions should
		throw an exception if the "precision" bit is wrong
		(since the geometric instructions loose precision).
		See the manual about this!
	x)  Exceptions for unaligned load/stores. OpenBSD/landisk uses
	    this mechanism for its reboot code (machine_reset).

Dreamcast:
	x)  Try to make the ROM from my real Dreamcast boot correctly.
	x)  PVR:  Lots of stuff. See dev_pvr.c.
		x)  DMA to non-0x10000000
		x)  Textures...
		x)  Make it fast! if possible
	x)  G2 DMA
	x)  SPU: Sound emulation (ARM cpu).
	x)  LAN adapter (dev_mb8696x.c).  NetBSD root-on-nfs.
	x)  Better GDROM support
	x)  Modem
	x)  PCI bridge/bus?
	x)  Maple bus:
		x)  Correct controller input
		x)  Mouse input
	x)  Software emulation of BIOS calls:
		x)  GD-ROM emulation: Use the GDROM device.
		x)  Use the VGA font as a fake ROM font. (Better than
		    nothing.)
	x)  Make as many as possible of the KOS examples run!
	x)  More homebrew demos/games.
	x)  VME processor emulation? "(Sanyo LC8670 "Potato")" according to
	    Wikipedia, LC86K87 according to Comstedt's page. See
	    http://www.maushammer.com/vmu.html for a good description of
	    the differences between LC86104C and the one used in the VME.

POWER/PowerPC:
	x)  Fix DECR timer speed, so it matches the host.
	x)  NetBSD/prep 3.x triggers a possible bug in the emulator:
	    <wdc_exec_command(0xd005e514,0xd60cdd30,0,8,..)>
	      <ata_get_xfer(0,0xd60cdd30,0,8,..)>
	        <0x26c550(&ata_xfer_pool,2,0,8,..)>
	        <0x35c71c(0x3f27000,0,52,8,..)>
	      <ata_exec_xfer(0xd005e4c8,0x3f27000,0,13,..)>
	        <atastart(0xd005e4c8,0x3f27000,0,13,..)>
	          <__wdccommand_start(0xd005e4c8,0x3f27000,0,13,..)>
	            <bsw1(&prep_isa_io_space_tag,0x800001f6,0,176,..)>
		[ wdc: write to SDH: 0xb0 (sectorsize 2, lba=1, drive 1, head 0) ]
	            <wdcwait(0xd005e4c8,72,64,0xbb8,..)>
	              <0x198120(0xd005e4c8,72,64,0xbb8,..)>
	                <bsr1(&prep_isa_io_space_tag,0,0,0xbb8,..)>
	                <delay(100,0,0,0xbb8,..)>
	    Note: <bsr1(&prep_isa_io_space_tag,0,0,0xbb8,..)>
	x)  PPC optimizations; instr combs
	x)  64-bit stuff: either Linux on G5, or perhaps some hobbyist
		version of AIX? (if there exists such a thing)
	x)  macppc: adb controller; keyboard (for framebuffer mode)
	x)  make OpenBSD/macppc work (PCI controller stuff)
	x)  Floating point exception correctness.
	x)  Alignment exceptions.
	x)  Boot args for gxemul -xeg4 -d opendarwin-6.6.2.ppc.cdr ? http://web.mit.edu/darwin/www/

PReP:
	x)  Clock time! ("Bad battery blah blah")

Algor:
	o)  Other models than the P5064?
	o)  PCI interrupts... needed for stuff like the tlp NIC?

Malta:
	o)  Try FreeBSD/malta: https://wiki.freebsd.org/FreeBSD/MipsEmulation
	o)  Malta can perhaps have up to 2 GB RAM? Try same hack as for the SGI O2.
	o)  Reconfigurable PCI memory space would be nice (just like SGI O2).

SGI O2:
	differences between real hardware and NetBSD's header files?

		RED/GREEN LED: 1 on real hardware turns off, not on!

		nr of bits for the tile ptr

		20008 vs 30008 in crmfb?

		CRMFB_CMAP_OVL = 0x00051400. should be 0x54400? for "color map 17" for overlays?

		crime time bit mask?

		NetBSD's crmfb.c crmfb_set_palette says rgb in reverse maybe?:
			val = (r &lt;&lt; 8) | (g &lt;&lt; 16) | (b &lt;&lt; 24)

	clocks:
		Both NetBSD and OpenBSD drift over time.

	bus_pci / O2's pci:
		reconfigurable memory space redirect?
		ahc scsi controller! this will be very time consuming.
		http://mail-index.netbsd.org/port-sgimips/2015/09/24/msg000711.html
			has some "pcictl pci0 dump -d 1" output which may be worth comparing against.

	ds2502_get_eaddr: ds2502_read_rom failed!
		PROM complains during bootup. Needed to get further with bootp() diskless booting.
		Onewire protocol that depends on microsecond timing?

	netbsd starts in "enter pathname of shell" mode; should start netbooting
		in a more automated fashion?

	netbsd randomly quits 'startx' without showing anything?
		sometimes also randomly places windows differently.

	ps2 8242:
		openbsd's X11 doesn't detect keyboard/mouse?

	PROM in GXemul says "SGI-CRM, Rev B", but my real O2 says Rev C?

	graphics:
		allow other resolutions than 1280x1024? netbsd seems to support it (?).

		netbsd maybe still triggers some acceleration bugs when moving X11 windows?
		
		horrible_getputpixel:
			GBE_CMODE_RGB10 etc from openbsd's header file?
			performance?

		actually emulate "pipeline" and detect pipeline overruns,
			i.e. require guest OSes to wait? but then, when to
			execute commands in the pipeline? (low-prio)
			get -w 0xb5004000:
						LEVEL	RD_PTR	WR_PTR	BUF_START
				0x1e029a68	00	29	29	28
				0x1e02baea	00	2b	2b	2a
				0x1e03befa	00	3b	3b	3a
				0x1e029a68	00	29	29	28
				0x1e00a289	00	0a	0a	09
				0x1e03df7c	00	3d	3d	3c
				0x1e00003f	00	00	00	3f
				0x1e02fbee	00	2f	2f	2e
				0x1e02cb2b	00	2c	2c	2b
				0x1e00b2ca	00	0b	0b	0a
				0x1e008207	00	08	08	07
				0x1e = all idle

		i2c vga data, for NetBSD etc.
		3D graphics? i.e. depth buffers, triangles, etc.

	audio?
		would be the first audio related thing in gxemul...

	VICE?

	video? probably too complicated.

	IRIX? Networking? SCSI? Currently panics due to root vfs not available.

HPCmips:
	x)  MIPS hibernate instruction => make the exit from the emulator nicer!
	x)  Clock? Is it running at correct speed?
	x)  Mouse/pad support! :)
	x)  A NIC? (As a PCMCIA device?)

ARM:
	o)  Big endian does not really work: loads and stores are little endian!
	o)  More THUMB disassembly?
	o)  More THUMB execution.
	o)  0xf "condition" execution: see http://engold.ui.ac.ir/~nikmehr/Appendix_B2.pdf
	o)  Android devices.
	o)  See netwinder_reset() in NetBSD; the current "an internal error
	    occured" message after reboot/halt is too ugly.
	o)  Generic ARM "wait"-like instruction?
	o)  try to get netbsd/evbarm 3.x or 4.x running (iq80321)
	o)  netbsd/iyonix? the i80321 device currently tells netbsd that
	    RAM starts at 0xa0000000, but that is perhaps not correct for the iyonix.
	o)  make the xscale counter registers (ccnt) work
	o)  make the ata controller usable for FreeBSD!
	o)  Debian/cats crashes because of unimplemented coproc stuff. fix this?

Test machines:
	o)  dev_fb 2D acceleration functions, to make dev_fb useful for simple graphical OSes:
		x) block fill and copy
		x) draw characters (from the built-in font)?
	o)  dev_fb input device? mouse pointer coordinates and buttons
		(allow changes in these to cause interrupts as well?)
	o)  Redefine the halt() function so that it stops "sometimes
	    soon", i.e. usage in demo code should be:
		for (;;) {
			halt();
		}
	o)  More demos/examples.

Dyntrans:
	x)  Try to make the vaddr fix O(1) again instead of O(n), if it
		is possible to see if a non-canonical address has been
		inserted into the caches. In other words, keep track of	
		whether a full O(n) seach is really needed or not.
	x)  For 32-bit emulation modes, that have emulated TLBs: tlbindex
	    arrays of mapped pages? Things to think about:
		x)  Only 32-bit mode! (64-bit => too much code)
		x)  One array for global pages, and one array _PER ASID_,
		    for those archs that support that. On M88K, there should
		    be one array for userspace, and one for supervisor, etc.
		x)  Larger-than-4K-pages must fill several bits in the array.
		x)  No TLB search will be necessary.
		x)  Total host space used, for 4 KB pages: 1 MB per table,
		    i.e. 65 MB for 32-bit MIPS, 2 MB for M88K, if one byte
		    is used as the tlb index.
		x)  (The index is actually +1, so that 0 means no hit.)
	x)  "Merge" the cur_physpage and cur_ic_page variables/pointers to
	    one? I.e. change cur_ic_page to cur_physpage.ic_page or something.
	x)  Instruction combination collisions? How to avoid easily...
	x)  superh -- no hostpage for e.g. 0x8c000000. devices as ram!
	x)  Think about how to do both SHmedia and SHcompact in a reasonable
	    way! (Or AMD64 long/protected/real, for that matter.)
	x)  68K emulation; think about how to do variable instruction
	    lengths across page boundaries.
	x)  Dyntrans with valgrind-inspired memory checker. (In memory_rw,
	    it would be reasonably simple to add; in each individual fast
	    load/store routine = a lot more work, and it would become
	    kludgy very fast.)
		o)  Mark every address with bits which tell whether or not the address
		    has been written to.
		o)  What should happen when programs are loaded?  Text/data, bss (zero
		    filled). But stack space and heap is uninitialized.
		o)  Uninitialized local variables:
			A load from a place on the stack which has not previously
			been stored to => warning. Increasing the stack pointer using
			any available means should reset the memory to uninitialized.
		o)  If calls to malloc() and free() can be intercepted:
			o)  Access to a memory area after free() => warning.
			o)  Memory returned by malloc() is marked as not-initialized.
			o)  Non-passive, but good to have: Change the argument
			    given to malloc, to return a slightly larger memory
			    area, i.e.  margin_before + size + margin_after,
			    and return the pointer  + margin_before.
			    Any access to the margin_before or _after space results
			    in warnings. (free() must be modified to free the
			    actually allocated address.)
	x)  Dyntrans with SMP... lots of work to be done here.
	x)  Dyntrans with cache emulation... lots of work here as well.
	x)  Remove the concept of base RAM completely; it would be more
	    generic to allow RAM devices to be used "anywhere".
	o)  dev_mp doesn't work well with dyntrans yet
	o)  In general, IPIs, CAS, LL/SC etc must be made to work with dyntrans
	x)  Redesign/rethink the delay slot mechanism used for e.g. MIPS,
		so that it caches a translation (that is, an instruction
		word and the instr_call it was translated to the last
		time), so that it doesn't need to do slow
		to_be_translated for each end of page?
	x)  Program Counter statistics:
		Per machine? What about SMP? All data to the same file?
		A debugger command should be possible to use to enable/
		disable statistics gathering.
		Configuration file option!
	x)  Breakpoints:
		o) Physical vs virtual addresses!
		o) 32-bit vs 64-bit sign extension for MIPS, and others?
	x)  INVALIDATION should cause translations in _all_ cpus to be
	    invalidated, e.g. on a write to a write-protected page
	    (containing code)
	x)  16-bit encodings? (MIPS16, ARM Thumb, etc)
	x)  Lots of other stuff: see src/cpus/README_DYNTRANS
	x)  Native code generation backends... think _carefully_ about this.
	    (Not a priority right now.)

Better CD Image file support:
	x)  Support CD formats that contain more than 1 track, e.g.
	    CDI files (?). These can then contain a mixture of e.g. sound
	    and data tracks, and booting from an ISO filesystem path
	    would boot from [by default] the first data track.
	    (This would make sense for e.g. Dreamcast CD images, or
	    possibly other live-CD formats.)

Networking:
	x)  Also adding support for connecting ttys (either to xterms, or to
		pipes/sockets etc, or even to PPP->NAT or SLIP->NAT :-).
	x)  Documentation updates (!) are very important, making it easier to
		use the (already existing) network emulation features.
	x)  Fix performance problems caused by only allowing a
	    single TCP packet to be unacked.
	x)  Don't hardcode offsets into packets!
	x)  Test with lower than 100 max tcp/udp connections,
	    to make sure that reuse works!
	x)  Multiple networks per emulation, and let different
	    NICs in machines connect to different networks.
	x)  Allow SLIP connections, possibly PPP, in addition to ethernet?

PCI:
	o)  Big-endian Malta access?
	x)  Pretty much everything related to runtime configuration, device
	    slots, interrupts, etc must be redesigned/cleaned up. The current
	    code is very hardcoded and ugly.
	o)  Allow cards to be added/removed during runtime more easily.
	o)  Allow cards to be enabled/disabled (i/o ports, etc, like
	    NetBSD needs for disk controller detection).
	o)  Allow devices to be moved in memory during runtime.
	o)  Interrupts per PCI slot, etc. (A-D).
	o)  PCI interrupt controller logic... very hard to get right,
	    because these differ a lot from one machine to the next.
	x)  last write was ffffffff ==> fix this, it should be used
	    together with a mask to get the correct bits. also, not ALL
	    bits are size bits! (lowest 4 vs lowest 2?)
	x)  add support for address fixups
	x)  generalize the interrupt routing stuff (lines etc)

Clocks and timers:
	x)  Fix the PowerPC DECR interrupt speed! (MacPPC and PReP speed, etc.)
	x)  DON'T HARDCODE 100 HZ IN cpu_mips_coproc.c!
	x)  NetWinder timeofday is incorrect! Huh? grep -R for ta_rtc_read in
	    NetBSD sources; it doesn't seem to be initialized _AT ALL_?!
	x)  Cobalt TOD is incorrect!
	x)  Go through all other machines, one by one, and fix them.

ASC SCSI controller:
	x)  NetBSD/arc 2.0 uses the ASC controller in a way which GXemul
	    cannot yet handle. (NetBSD 1.6.2 works ok.) (Possibly a problem
	    in NetBSD itself, http://mail-index.netbsd.org/source-changes/
	    2005/11/06/0024.html suggests that.)
	    NetBSD 4.x seems to work? :)

Better framebuffer and X-windows functionality:
	o)  Do a complete rewrite of the framebuffer/console stuff, so that:
		1)  It does not rely on X11 specifically.
		2)  It is possible to interact with emulated framebuffers
		    and consoles "remotely", e.g. via a web page which
		    controls multiple virtualized machines.
		3)  It is possible to run on (hypothetical) non-X11
		    graphics systems.
	o)  Generalize the update_x1y1x2y2 stuff to an extend-region()
	    function...
	o)  -Yx sometimes causes crashes.
	o)  Simple device access to framebuffer_blockcopyfill() etc,
	    and text output (using the built-in fonts), for dev_fb.
	o)  CLEAN UP the ugly event code
	o)  Mouse clicks can be "missed" in the current system; this is
	    not good. They should be put on a stack of some kind.
	o)  More 2D and 3D framebuffer acceleration.
	o)  Non-resizable windows?  Or choose scaledown depending
		on size (and center the image, with a black border).
	o)  Different scaledown on different windows?
	o)  Non-integral scale-up? (E.g. 640x480 -> 1024x768)
	o)  Switch scaledown during runtime? (Ala CTRL-ALT-plus/minus)
	o)  Bug reported by Elijah Rutschman on MacOS with weird
	    keys (F5 = cursor down?).
	o)  Keyboard and mouse events:
		x)  Do this for more machines than just DECstation
		x)  more X11 cursor keycodes
		x)  Keys like CTRL, ALT, SHIFT do not get through
		    by themselves (these are necessary for example
		    to change the font of an xterm in X in the
		    emulator)
	o)  Generalize the framebuffer stuff by moving _ALL_ X11
		specific code to a separate module.
</pre>




<p><br>
<b><a name="release">Release checklist</a></b>

<p><ul>
	<li>Pre-release regression testing:
	<ul>
		<li>Build on as many platforms as possible, including inside guest OSes in GXemul itself.
		<li>If there is time: Install as many as possible of the guest OSes in the documentation;
		the documentation may need to be updated if there are regressions.
		<li>If there is more time: try newer versions of the officially
			supported guest OSes (sometimes these work, sometimes not).
		<li>If there is even more time: see what the status is for the
			"unsupported" guest OSes as well.
	</ul>
	<li>Release build, update notes etc:
	<ul>
		<li>Update the <tt>README</tt> and <tt>RELEASE</tt> notes.
		<li>TODO updates (i.e. set goals for the <i>next</i> release, if possible,
			or strike out things that have been fixed).
		<li>HISTORY (mention the release).
		<li>Tarball creation (make_release.sh and just_update.sh)
		<li>Home page <i>Download page</i> update: version number and date.
		<li>Home page <i>News page</i> update: new Release.
		<li>Create subversion tag.
		<li>Sync subversion to SourceForge mirror.
		<li>Sync the homepage to the web server.
		<li>Sourceforge File Release (upload the tarball).
		<li>Mention release on #GXemul on FreeNode (IRC), set version number in topic if possible.
		<li>gxemul-users mail, content similar to the RELEASE notes.
	</ul>
</ul>

</body>
</html>

