<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>GXemul: Experimenting with GXemul</title>
  <meta name="robots" content="noarchive,nofollow,noindex">
</head>
<body style="font-family : sans-serif;">

<!-- 10 lines header.  -->

<h1>GXemul: Experimenting with GXemul</h1>
<p>

<a href="./">Back to the index.</a>

<!--

Copyright (C) 2003-2019  Anders Gavare.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

-->

<p><br>
<ul>
  <li><a href="#intro">Introduction to the GXemul command line</a>
  <ul>
	<li><a href="#launching">Launching the emulator</a>
	<li><a href="#unassemble">Unassembling machine code</a>
	<li><a href="#reg">Dumping CPU registers</a>
	<li><a href="#dump">Dumping memory contents</a>
	<li><a href="#step">Continuing execution or Single-stepping</a>
	<li><a href="#breakpoints">Breakpoints</a>
	<li><a href="#trace">Function call tracing</a>
  </ul>
  <li><a href="#hello">Hello world</a>
  <li><a href="#expdevices">Experimental devices</a>
</ul>



<p><br>
<a name="intro"></a>
<h3>Introduction to the GXemul command line:</h3>

Apart from running entire <a href="guestoses.html">guest operating systems</a>,
the emulator can also be used as a kind of debugger.

<p>These sections will quickly go through some of the basic concepts and commands
in GXemul.

<p>If you want to follow along with the exact commands as specified below,
you should start by downloading the program used in the examples. It is an 
OpenBSD kernel for LUNA 88K:

<p><a href="https://ftp.eu.openbsd.org/pub/OpenBSD/6.2/luna88k/bsd.rd">https://ftp.eu.openbsd.org/pub/OpenBSD/6.2/luna88k/bsd.rd</a>.

<p>You can run <tt>file bsd.rd</tt> to check that it is of a reasonable executable file format.

<pre>
$ <b>file bsd.rd</b>
bsd.rd: ELF 32-bit MSB executable, Motorola m88k, version 1 (SYSV), statically linked, not stripped
</pre>




<a name="launching"></a><h4>Launching the emulator</h4>


<p>When starting GXemul, we need to supplying the name of the machine we want to emulate (using <tt>-e</tt>) and the 
kernel we want to run/debug.

<pre>
$ <b>gxemul -e luna-88k bsd.rd</b>
</pre>

<p>This will start the emulator, start running the kernel, and, for this particular OpenBSD kernel (at least
at the time of writing this text), exit at the end, because the
emulator does not fully support running that kernel on that emulated machine type. But it is
enough to demonstrate the various commands that you can use.

<p>You really need to know what machine type you want to emulate. The emulator cannot simply load a binary
without having a machine to load it into. There are some machine types called "testXXXX" or "bareXXXX"
which are minimal machines with just a CPU (bareXXXX) or just a CPU plus some test devices (testXXXX),
but these do not correspond to any real world machine.

<p>The next very useful command line switch, when using the emulator as a debugger, is <tt>-V</tt>. This causes
the emulator to start in a <i>paused state</i>, showing a <tt>GXemul&gt;</tt> prompt where commands can be entered.

<pre>
$ <b>gxemul -V -e luna-88k bsd.rd</b>
GXemul (unknown version)    Copyright (C) 2003-2019  Anders Gavare
Read the source code and/or documentation for other Copyright messages.

Simple setup...
    net:
        simulated network: 10.0.0.0/8 (max outgoing: TCP=100, UDP=100)
        simulated gateway+nameserver: 10.0.0.254 (60:50:40:30:20:10)
        simulated nameserver uses real nameserver 192.168.8.1
    machine:
        memory: 112 MB
        cpu0: 88100
        machine: LUNA 88K
        loading bsd.rd
        cpu0: starting at 0x00081004
-------------------------------------------------------------------------------

GXemul> 
</pre>



<a name="unassemble"></a><h4>Unassembling machine code</h4>

Next, we want to look at the code in the program that we are about to run.

<pre>
GXemul> <b>unassemble</b>
&lt;__start>
s00081004: c0000004	br	0x00081014	; &lt;main_start>
s00081008: c0000003	br	0x00081014	; &lt;main_start>
s0008100c: c0000002	br	0x00081014	; &lt;main_start>
s00081010: c0000001	br	0x00081014	; &lt;main_start>
&lt;main_start>
s00081014: c80340a7	bsr	0x001512b0	; &lt;setup_psr>
s00081018: 800080e0	stcr	r0,VBR
s0008101c: f000d800	tb1	0,r0,0x0
s00081020: 5d600041	or.u	r11,r0,0x41
s00081024: 596b162c	or	r11,r11,0x162c	; &lt;cpu_hatch_mutex>
s00081028: f000d800	tb1	0,r0,0x0
s0008102c: 5ac00001	or	r22,r0,0x1
s00081030: f6cb0400	xmem	r22,r11,r0
s00081034: e8560007	bcnd	eq0,r22,0x00081050
s00081038: f6cb1400	ld	r22,r11,r0
s0008103c: e9b6ffff	bcnd	ne0,r22,0x00081038
s00081040: 584003e8	or	r2,r0,0x3e8
s00081044: 64420001	subu	r2,r2,1
s00081048: e842ffff	bcnd	eq0,r2,0x00081044
s0008104c: c3fffff7	br	0x00081028
s00081050: f000d800	tb1	0,r0,0x0
GXemul> 
</pre>

<p>In the example above, the <tt>unassemble</tt> command has been used to unassemble
the code which is about to be executed. You don't have to write out <tt>unassemble</tt>
all the time, you can just type <tt>u</tt>. If you type <tt>u</tt> followed by an
address, it will try to disassemble from that address. Typing just <tt>u</tt> will
continue unassembling from where it last unassembled, or, in the case of the first
invocation of that command, from the program's entry point.

<p>As you can see, there are annotations about <tt>&lt;main_start&gt;</tt>,
<tt>&lt;setup_psr&gt;</tt>, and so on. Those are symbols read from the file.
Usually, when an address is taken as an argument to a command such as <tt>unassemble</tt>,
you can type either a numeric address (usually hexadecimal with the 0x prefix)
or a symbol. Some simple arithmetic is allowed, typically useful to disassemble
some distance before a symbol or similar:

<pre>
GXemul> <b>u setup_psr-0x20</b>
s00151290: 20020028	st.d	r0,r2,0x28
s00151294: 20020030	st.d	r0,r2,0x30
s00151298: 20020038	st.d	r0,r2,0x38
s0015129c: 60420040	addu	r2,r2,64
s001512a0: f4827c0c	cmp	r4,r2,r12
s001512a4: d864fff6	bb1	3,r4,0x0015127c
s001512a8: f400c003	jmp	(r3)
s001512ac: f4005800	nop
&lt;setup_psr>
s001512b0: 80404000	ldcr	r2,PID
s001512b4: f0629908	extu	r3,r2,8<8>
s001512b8: 7c830001	cmp	r4,r3,1
s001512bc: d8440002	bb1	2,r4,0x001512c4
s001512c0: 80008060	stcr	r0,SSBR
s001512c4: 80008240	stcr	r0,SR1
s001512c8: 5c408000	or.u	r2,r0,0x8000
s001512cc: 584203f2	or	r2,r2,0x3f2	; 0x800003f2
s001512d0: 80028022	stcr	r2,PSR
s001512d4: f000d800	tb1	0,r0,0x0
s001512d8: f400c001	jmp	(r1)
&lt;set_vbr>
s001512dc: 80604020	ldcr	r3,PSR
GXemul> 
</pre>



<a name="reg"></a><h4>Dumping CPU registers</h4>


<p>To dump the register contents, use the <tt>reg</tt> command:

<pre>
GXemul> <b>reg</b>
cpu0:  pc  = 0x00081004  &lt;__start>
cpu0:                    r1  = 0x00000000  r2  = 0x00000000  r3  = 0x00000000
cpu0:  r4  = 0x00000000  r5  = 0x00000000  r6  = 0x00000000  r7  = 0x00000000
cpu0:  r8  = 0x00000000  r9  = 0x00000000  r10 = 0x00000000  r11 = 0x00000000
cpu0:  r12 = 0x00000000  r13 = 0x00000000  r14 = 0x00000000  r15 = 0x00000000
cpu0:  r16 = 0x00000000  r17 = 0x00000000  r18 = 0x00000000  r19 = 0x00000000
cpu0:  r20 = 0x00000000  r21 = 0x00000000  r22 = 0x00000000  r23 = 0x00000000
cpu0:  r24 = 0x00000000  r25 = 0x00000000  r26 = 0x00000000  r27 = 0x00000000
cpu0:  r28 = 0x00000000  r29 = 0x00000000  r30 = 0x00000000  r31 = 0x06fffc00
</pre>

<p>You can modify registers by typing commands such as <tt>r8 = r31 + 0x1234</tt>.





<a name="dump"></a><h4>Dumping memory contents</h4>


<p>Similar to <tt>unassemble</tt>, there is a <tt>dump</tt> command.
Note that you can use register names too, not just symbol names, in the
address expressions:

<pre>
GXemul> <b>dump pc+64</b>
0x00081040           64420001 e842ffff c3fffff7      dB...B......
0x00081050  f000d800 5d600020 596b7004 5ac00001  ....]`. Ykp.Z...
0x00081060  f6cb0400 e9b60037 5c400041 58423ef8  .......7\@.AXB>.
0x00081070  5c800047 588452c0 cc032402 f4646402  \..GX.R...$..dd.
0x00081080  5c800047 588452c0 5ca00047 24854c1c  \..GX.R.\..G$.L.
0x00081090  5d600040 596bc1b8 800b822b 5fe00020  ]`.@Yk.....+_.. 
0x000810a0  5bff5000 5c600040 5863c9e4 cc03f661  [.P.\`.@Xc.....a
0x000810b0  804040e0 594000b6 5d604900 2d4b000c  .@@.Y@..]`I.-K..
0x000810c0  0d4b0000 f14aa008 0d8b0004 f54a580c  .K...J.......JX.
0x000810d0  5d600041 294b1654 d9ca0004 f5405800  ]`.A)K.T.....@X.
0x000810e0  5d600041 254b1650 15401114 5d600047  ]`.A%K.P.@..]`.G
0x000810f0  254b4b98 59400084 5d604d00 2d4b000c  %KK.Y@..]`M.-K..
0x00081100  59400009 2d4b000c 5d40e100 1d6a0010  Y@..-K..]@...j..
0x00081110  2d6a0010 5c404100 24020000 c803f65d  -j..\@A.$......]
0x00081120  81404220 17ea0008 63ff2000 c8002de1  .@B ....c. ...-.
0x00081130  5c400020 cc00d1db 58420000 f4005800  \@. ....XB....X.
0x00081140  c0000000                             ....            
GXemul>
</pre>



<a name="step"></a><h4>Continuing execution or Single-stepping</h4>


<p>Now, if you want to start running the emulation (just as if the <tt>-V</tt> command line
option had not been used), type <tt>continue</tt> at the <tt>GXemul&gt;</tt> prompt,
or simply <tt>c</tt>, and press enter.

If not, you may want to just run a few instructions at a time in order to see where the
program is going. By typing <tt>step</tt> (or just <tt>s</tt>) followed by a number,
the emulator will single-step that number of instructions. If the number is omitted,
it will execute 1.

<pre>
GXemul> <b>step 7</b>
&lt;__start>
s00081004: c0000004	br	0x00081014	; &lt;main_start>
&lt;main_start>
s00081014: c80340a7	bsr	0x001512b0	; &lt;setup_psr>
&lt;setup_psr(0,0,0,0,0,0,0,0,..)>
&lt;setup_psr>
s001512b0: 80404000	ldcr	r2,PID		; PID = 0x00000007
s001512b4: f0629908	extu	r3,r2,8&lt;8>
s001512b8: 7c830001	cmp	r4,r3,1
s001512bc: d8440002	bb1	2,r4,0x001512c4
s001512c0: 80008060	stcr	r0,SSBR		; r0 = 0x00000000
GXemul> 
s001512c4: 80008240	stcr	r0,SR1		; r0 = 0x00000000
GXemul>
</pre>

<p>Note that when single-stepping, as opposed to just unassembling, there may be some
additional info as "comments" regarding register contents or other things.

<p>As a convenience, when single-stepping, you can just press enter (entering a blank line), which
will do the same thing as <tt>s 1</tt>.




<a name="breakpoints"></a><h4>Breakpoints</h4>

There are two ways to set breakpoints. If you only need to set one or more breakpoints and run
until the first breakpoint is hit, you can start the emulator with one or more <tt>-p</tt> flags.
Here is an example:

<pre>
$ <b>gxemul -p bcopy -e luna-88k bsd.rd</b>
</pre>

<p>That will run the program until the program counter reaches the symbol (or address) <tt>bcopy</tt>.

<p>Alternatively, breakpoints can be added interactively from the <tt>GXemul&gt;</tt> prompt using
<tt>breakpoint add</tt>:

<pre>
$ <b>gxemul -V -e luna-88k bsd.rd</b>
GXemul (unknown version)    Copyright (C) 2003-2019  Anders Gavare
...

GXemul> <b>breakpoint add bcopy</b>
  0: 0x0014a170 (bcopy)
GXemul> <b>c</b>
CPU0 is associated to 2 MC88200 CMMUs
CPU1 is associated to 2 MC88200 CMMUs
CPU2 is associated to 2 MC88200 CMMUs
CPU3 is associated to 2 MC88200 CMMUs
Copyright (c) 1982, 1986, 1989, 1991, 1993
	The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2018 OpenBSD. All rights reserved.  https://www.OpenBSD.org

OpenBSD 6.4 (RAMDISK) #0: Sat Oct 20 07:14:59 JST 2018
    aoyama@rhea.in.nk-home.net:/w1/o/6.4/src/sys/arch/luna88k/compile/RAMDISK
real mem = 117440512 (112MB)
avail mem = 110448640 (105MB)
mainbus0 at root: OMRON LUNA-88K, 25MHz
cpu0: M88100 rev 0x3, 2 CMMU
cpu0: M88200 (16K) rev 0x9, full Icache
cpu0: M88200 (16K) rev 0x9, full Dcache
clock0 at mainbus0: MK48T02
le0 at mainbus0: address 00:00:00:00:00:00
le0: 32 receive buffers, 8 transmit buffers
&lt;bcopy>
s0014a170: e84400a6	bcnd	eq0,r4,0x0014a408	; &lt;bcopy_out>
BREAKPOINT: pc = 0x14a170
(The instruction has not yet executed.)
GXemul> 
</pre>



<a name="trace"></a><h4>Function call tracing</h4>

<p>Function call trace is toggled using the <tt>trace</tt> command from the
<tt>GXemul&gt;</tt> prompt, or using the <tt>-t</tt> command line option. This will attempt
to show subroutine calls with arguments, although it does not really know the function
signatures so it will just make a crude guess as to what an argument is.
Each call to a subroutine should increment the indentation, and each return
should decrement it. Sometimes it works, sometimes it doesn't. The number of
arguments is also not known, so it just prints a bunch of them.

<pre>
$ <b>gxemul -t -p badaddr -e luna-88k bsd.rd</b>
...
-------------------------------------------------------------------------------

&lt;__start(0,0,0,0,0,0,0,0,..)>
  &lt;setup_psr(0,0,0,0,0,0,0,0,..)>
  &lt;bzero(&amp;edata,0x613c8)>
  &lt;luna88k_vector_init(0,&amp;vector_list,&amp;end,0x470000,"$",0,0,0,..)>
    &lt;vector_init(0,&amp;vector_list,1,0x470000,"$",0,0,0,..)>
    &lt;vector_init(&amp;kernelstart,&amp;vector_list,0,0x470000,0xc005f0fc,0xc005f09a,0xc005f0fc,0x17c3f0,..)>
  &lt;luna88k_bootstrap(0x41000000,&amp;vector_list,0,0x470000,0xc003f0fc,0xc003f09a,0xc003f0fc,0x17c3f0,..)>
    &lt;uvm_setpagesize(0x41000000,&amp;vector_list,0,0x470000,0xc003f0fc,0xc003f09a,0xc003f0fc,0x17c3f0,..)>
    &lt;size_memory(0x41000000,&amp;vector_list,0,0x470000,0xc003f0fc,0xc003f09a,0xc003f0fc,0x470000,..)>
      &lt;badaddr(0x476000,4,0,0x470000,0xc003f0fc,0xc003f09a,0xc003f0fc,0x470000,..)>
&lt;badaddr>
s0017d574: 81004020	ldcr	r8,PSR		; PSR = 0x800003f2
BREAKPOINT: pc = 0x17d574
(The instruction has not yet executed.)
GXemul>
</pre>

<p>In this example, some of the arguments are guessed to be small integers (e.g. 0 or 4),
large integers or general pointer values (prefixed with 0x), or addresses of known
symbols (&amp;vector_list). Strings are also sometimes shown, if an argument looks like
readable memory which points to a string.




<p><br>
<a name="hello"></a>
<h3>Hello world:</h3>

<p>You might want to use the emulator to develop programs on your own,
not just run already existing operating system kernels such as NetBSD.
To get started, I recommend that you do two things:

<p>
<ul>
  <li>Build and install a cross-compiler for your chosen target,
	e.g. <tt>mips64-unknown-elf</tt>.
	<a href="http://gcc.gnu.org/">GCC</a> is usually a good compiler
	choice, because it is portable and in wide-spread use.
	(Other compilers should work too.)
  <p>
  <li>Compile the Hello World demo program for your chosen target, and run 
	it in the emulator.
</ul>

<p>The Hello World demo program is included in the GXemul source
code distribution, in the <a href="../demos/hello/"><tt>demos/hello/</tt></a>
subdirectory. The README files in the demo directories have several 
examples of how the demo programs can be built.

<p>Once you have compiled the Hello World program into a binary,
<tt>hello_mips</tt>, start it like this:
<pre>
	<b>gxemul -E oldtestmips hello_mips</b>
</pre>

<p>Then you can experiment using the commands further up on this page.

<p>If you start the emulator in the paused state, or if you press CTRL-C 
during normal execution, you will end up with a <tt><b>GXemul></b></tt> 
prompt.

<p>Hopefully this is enough to get you inspired. :-)






<p><br>
<a name="expdevices"></a>
<h3>Experimental devices:</h3>

The emulator has several modes where it doesn't emulate any real machine.
It can either run in "bare" mode, where no devices are included by default
(just the CPU), or in a "test" mode where some simple devices are 
emulated.

<p>The test machines (<tt>oldtestmips</tt>, <tt>testppc</tt>, etc) have the
following experimental devices:

<p>
<center><table border="0" width="80%">

  <tr>
    <td align="left" valign="top" width="200">
	<a name="expdevices_cons"><b><tt>cons</tt>:</b></a>
	<p>A simple console device, for writing
	characters to the controlling terminal
	and receiving keypresses.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_cons.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_cons.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x10000000</font>
    </td>
    <td align="left" valign="top" width="25">&nbsp;</td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00</tt></td>
	    <td align="left" valign="top">
		Read: <b><tt>getchar()</tt></b> (non-blocking; returns
		<tt>0</tt> if no char was available)<br>
		Write: <b><tt>putchar(ch)</tt></b></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x10</tt></td>
	    <td align="left" valign="top">Read or write: <b><tt>halt()</tt></b><br>
		(Useful for exiting the emulator.)</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<a name="expdevices_mp"><b><tt>mp</tt>:</b></a>
	<p>This device controls the behaviour of CPUs in an emulated
	multi-processor system.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_mp.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_mp.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x11000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000</tt></td>
	    <td align="left" valign="top">Read: <b><tt>whoami()</tt></b>.
		Returns the id of the CPU doing the read.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0010</tt></td>
	    <td align="left" valign="top">Read: <b><tt>ncpus()</tt></b>.
		Returns the number of CPUs in the system.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0020</tt></td>
	    <td align="left" valign="top">Write: <b><tt>startupcpu(i)</tt></b>.
		Starts CPU i. It begins execution at the address
		set by a write to startupaddr (see below).</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0030</tt></td>
	    <td align="left" valign="top">Write: <b><tt>startupaddr(addr)</tt></b>.
		Sets the starting address for CPUs.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0040</tt></td>
	    <td align="left" valign="top">Write: <b><tt>pause_addr(addr)</tt></b>.
		Sets the pause address. (NOTE: This is not
		used anymore.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0050</tt></td>
	    <td align="left" valign="top">Write: <b><tt>pause_cpu(i)</tt></b>.
		Pauses all CPUs <i>except</i> CPU i.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0060</tt></td>
	    <td align="left" valign="top">Write: <b><tt>unpause_cpu(i)</tt></b>.
		Unpauses CPU i.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0070</tt></td>
	    <td align="left" valign="top">Write: <b><tt>startupstack(addr)</tt></b>.
		Sets the startup stack address. (CPUs started with
		startupcpu() above will have their stack pointer
		set to this value.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0080</tt></td>
	    <td align="left" valign="top">Read: <b><tt>hardware_random()</tt></b>.
		This produces a "random" number.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0090</tt></td>
	    <td align="left" valign="top">Read: <b><tt>memory()</tt></b>.
		Returns the number of bytes of RAM in the system.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00a0</tt></td>
	    <td align="left" valign="top">Write: <b><tt>ipi_one((nr &lt;&lt; 16) + cpuid)</tt></b>.
		Sends IPI <tt>nr</tt> to a specific CPU.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00b0</tt></td>
	    <td align="left" valign="top">Write: <b><tt>ipi_many((nr &lt;&lt; 16) + cpuid)</tt></b>.
		Sends IPI <tt>nr</tt> to all CPUs <i>except</i>
		the specified one.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00c0</tt></td>
	    <td align="left" valign="top">Read: <b><tt>ipi_read()</tt></b>.
		Returns the next pending IPI. 0 is returned if there is no 
		pending IPI (so 0 shouldn't be used for valid IPIs).
		Hardware int 6 is deasserted when the IPI queue is empty.
	    <br>Write: <b><tt>ipi_flush()</tt></b>.
		Clears the IPI queue, discarding any pending IPIs.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00d0</tt></td>
	    <td align="left" valign="top">Read: <b><tt>ncycles()</tt></b>.
		Returns approximately the number of cycles executed on
		this CPU. Note: this value is not updated for every instruction,
		so it cannot be used for small measurements.</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<a name="expdevices_fb"><b><tt>fb</tt>:</b></a>
	<p>A simple linear framebuffer, for graphics output.
	640 x 480 pixels, 3 bytes per pixel (red, green, blue, 8 bits each).
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_fb.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_fb.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x12000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x00000-</tt><br><tt>0xe0fff</tt></td>
	    <td align="left" valign="top">Read: read pixel values.
		<br>Write: write pixel values.</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<a name="expdevices_disk"><b><tt>disk</tt>:</b></a>
	<p>Disk controller, which can read from and write
	to emulated IDE disks. It does not use interrupts; read and
	write operations finish instantaneously.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_disk.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_disk.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x13000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000</tt></td>
	    <td align="left" valign="top">Write: Set the offset (in bytes) from the beginning
		of the disk image. This offset will be used for the next read/write operation.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0008</tt></td>
	    <td align="left" valign="top">Write: Set the high 32 
		bits of the offset (in bytes). (*)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0010</tt></td>
	    <td align="left" valign="top">Write: Select the IDE ID to be used in the next
		read/write operation.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0020</tt></td>
	    <td align="left" valign="top">Write: Start a read or write operation.
		(Writing <tt>0</tt> means a Read operation, a <tt>1</tt> means a
		Write operation.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0030</tt></td>
	    <td align="left" valign="top">Read: Get status of the last operation.
		(Status 0 means failure, non-zero means success.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4000-</tt><br><tt>0x41ff</tt>&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top">Read/Write: 512 bytes data buffer.</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<a name="expdevices_ether"><b><tt>ether</tt>:</b></a>
	<p>A simple ethernet controller, enough to send
	and receive packets on a simulated network.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_ether.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_ether.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x14000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000-</tt><br><tt>0x3fff</tt></td>
	    <td align="left" valign="top">Read/write buffer for the packet to be sent/received.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4000</tt></td>
	    <td align="left" valign="top">Read: status word, one or more of these:
		<br><tt>0x01</tt>&nbsp;=&nbsp;something was received (because of
		the last command)
		<br><tt>0x02</tt>&nbsp;=&nbsp;more packets are available
		<br><i>NOTE:</i> Whenever the status word is non-zero,
			an interrupt is asserted. Reading the status word
			clears it, and deasserts the interrupt.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4010</tt></td>
	    <td align="left" valign="top">Read: get the Length of the received packet
		<br>Write: set the Length of the next packet to transmit</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4020</tt></td>
	    <td align="left" valign="top">Write: command:
		<br><tt>0x00:</tt>&nbsp;receive a packet
		<br><tt>0x01:</tt>&nbsp;send a packet</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4040</tt></td>
	    <td align="left" valign="top">Write: an address, where the emulated
	    	MAC address will be copied to.
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<a name="expdevices_rtc"><b><tt>rtc</tt>:</b></a>
	<p>A Real-Time Clock, used to retrieve the current time
	and to cause periodic interrupts.
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_rtc.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_rtc.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x15000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0000</tt></td>
	    <td align="left" valign="top">Read or Write: Trigger a clock update (a gettimeofday() on the host).</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0010</tt></td>
	    <td align="left" valign="top">Read: Seconds since 1st January 1970</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0020</tt></td>
	    <td align="left" valign="top">Read: Microseconds</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0100</tt></td>
	    <td align="left" valign="top">Read: Get the current
		timer interrupt frequency.<br>Write: Set the timer
		interrupt frequency. (Writing 0 disables the timer.)</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0110</tt></td>
	    <td align="left" valign="top">Read or Write: Acknowledge
		one timer interrupt. (Note that if multiple interrupts
		are pending, only one is acknowledged.)</td>
	  </tr>
	</table>
    </td>
  </tr>

  <tr height="15">
    <td height="15">&nbsp;</td>
  </tr>

  <tr>
    <td align="left" valign="top">
	<a name="expdevices_irqc"><b><tt>irqc</tt>:</b></a>
	<p>An Interrupt Controller. (Note: Not used for the MIPS test machine.)
	<p>Source code:&nbsp;&nbsp;<font color="#0000f0"><tt>src/devices/dev_irqc.c</tt></font>
	<p>Include file:&nbsp;&nbsp;<font color="#0000f0"><tt>dev_irqc.h</tt></font>
	<br>Default physical address:&nbsp&nbsp;<font color="#0000f0">0x16000000</font>
    </td>
    <td></td>
    <td align="left" valign="top">
	<table border="0">
	  <tr>
	    <td align="left" valign="top"><i><u>Offset:</u></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	    <td align="left" valign="top"><i><u>Effect:</u></i></td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x0</tt></td>
	    <td align="left" valign="top">Read: IRQ status as a 32-bit word, one bit per interrupt source.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x4</tt></td>
	    <td align="left" valign="top">Write: Mask one interrupt source. Value should be an integer 0..31.</td>
	  </tr>
	  <tr>
	    <td align="left" valign="top"><tt>0x8</tt></td>
	    <td align="left" valign="top">Write: Unmask one interrupt source. Value should be an integer 0..31.</td>
	  </tr>
	</table>
    </td>
  </tr>

</table></center>

<p>(*)  Note:  If the emulated architecture has the capability to write 64-bit
words atomically, then writing to offset 0x0000 of the
<tt>disk</tt> device should be enough to set the offset. For 32-bit
architectures, the lowest 32 bits of the disk offset should first be 
written to the register at offset 0x0000, and the top 32 bits should
then be written to the register at offset 0x0008.

<p>The include files for the test machine devices are found in
<a href="../src/include/testmachine/"><tt>src/include/testmachine/</tt></a>.

<p>While these devices may resemble real-world hardware, they are 
intentionally made simpler to use. (An exception is the framebuffer;
some machines actually have simple linear framebuffers like this.)

<p>If the physical address is <tt>0x10000000</tt>, then for MIPS that
means that it can be accessed at virtual address
<tt>0xffffffffb0000000</tt>. (Actually it can be accessed at
<tt>0xffffffff90000000</tt> too, but devices should usually be accessed in
a non-cached manner.)

<p>When using the ARM or PPC test machines, the addresses are
<tt>0x10000000</tt>, <tt>0x11000000</tt> etc., so no need to add any
virtual displacement.

<p>The <tt>mp</tt>, <tt>disk</tt>, and <tt>ether</tt> devices are agnostic 
when it comes to word-length. For example, when reading offset 
<tt>0x0000</tt> of the <tt>mp</tt> device, you may use any kind of read 
(an 8-bit read will work just as well as a 64-bit read, although the value 
will be truncated to 8 bits in the first case). You can <i>not</i>, 
however, read one byte from <tt>0x0000</tt> and one from <tt>0x0001</tt>, 
and combine the result. The read from <tt>0x0001</tt> will be invalid.

<p>The <tt>cons</tt> device should be accessed using 8-bit reads 
and writes. Doing a getchar() (ie reading from offset <tt>0x00</tt>)  
returns <tt>0</tt> if no character was available. Whenever a character is 
available, the <tt>cons</tt> device' interrupt is asserted. When there are 
no more available characters, the interrupt is deasserted. (Remember that 
the interrupt has to be unmasked to be able to actually cause an 
interrupt.)

<p>IPIs (inter-processor interrupts) are controlled by the <tt>mp</tt> 
device. Whenever an IPI is "sent" from a source to one or more target 
CPUs, the interrupt is asserted on the target CPUs, and the IPI number is 
added last in the IPI queue for each of the target CPUs. It is then up to 
those CPUs to individually read from offset <tt>0x00c0</tt>, to figure out 
what kind of IPI it was.



<p>Interrupt mappings are as follows:

<p><center>
<table border="1">
	<tr><td align="center">
		<b><tt>oldtestmips</tt></b> (as native MIPS interrupts)
	</td></tr>
	<tr><td>
		<table border="0">
		<tr><td align="center">IRQ:</td><td>&nbsp;</td>
			<td>Used for:</td></tr>
		<tr><td align="center">7</td><td></td>
			<td>MIPS count/compare interrupt</td></tr>
		<tr><td align="center">6</td><td></td>
			<td><tt>mp</tt> (inter-processor interrupts)</td></tr>
		<tr><td align="center">4</td><td></td>
			<td><tt>rtc</tt></td></tr>
		<tr><td align="center">3</td><td></td>
			<td><tt>ether</tt></td></tr>
		<tr><td align="center">2</td><td></td>
			<td><tt>cons</tt></td></tr>
		</table>
	</td></tr>
</table>

<p><table border="1">
	<tr><td align="center">
		<b><tt>testarm</tt> and others</b> (via the <tt>irqc</tt> device)
	</td></tr>
	<tr><td>
		<table border="0">
		<tr><td align="center">IRQ:</td><td>&nbsp;</td>
			<td>Used for:</td></tr>
		<tr><td align="center">6</td><td></td>
			<td><tt>mp</tt> (inter-processor interrupts)</td></tr>
		<tr><td align="center">4</td><td></td>
			<td><tt>rtc</tt></td></tr>
		<tr><td align="center">3</td><td></td>
			<td><tt>ether</tt></td></tr>
		<tr><td align="center">2</td><td></td>
			<td><tt>cons</tt></td></tr>
		</table>
	</td></tr>
</table>
</center>



<p><br>



</p>

</body>
</html>
